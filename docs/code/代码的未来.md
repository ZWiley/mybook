# 1 编程的本质
编程的本质是思考

极限思考法：假如 cpu ssd 等发挥极致


# 2. 编程语言的过去、现在和未来
图灵完备：指一种计算模型拥有和通用图灵机相同的计算能力，即一种计算模型可以对目前已知所有算法的描述。
抽象化

2.2 DSL：领域特定语言。外部DSL 和 内部DSL（更有优势，借宿 宿主语言）
一个优秀内部DSL五个要素：上下文、语句、单位、词汇、层次结构

BDD（行为驱动开发）：软件开发之前就设计好规格

给一种模式起个名字能提高认知

2.3 元编程

元数据：描述数据所具有的结构的数据，也就是关于数据本身的数据
元编程：用程序来写程序。环境允许程序本身作为数据结构操作
反射。
ruby中类也是对象

2.4 内存管理

抖动（thrushing）:使用硬盘作为虚拟内存后和硬盘数据交互过于频繁，处理速度就会下降
GC(Garabage Collection)
垃圾(Garabage): 需要回收的对象。GC的本质就是找出已经引用不到的对象（死亡），然后作为垃圾回收。
根（Root）：判断对象是否可被引用的起始点。基本是将变量和运行占空间作为跟
- 标记清除（mark and sweep）：首先从跟开始姜可能被引用的对象用递归方式标记，然后将没有标记到的对象作为垃圾进行回收。处理时间和存活对象数与对象总数的总和相关。
- 标记压缩（mark and compact）:不是清楚被标记的对象，而是不断压缩
- 复制收集(copy and collection): 从根开始被引用的对象复制到另外的空间中
- 引用计数（reference count）:在每个对象中爆保存该对象的引用计数，当引用发生增减时候对计数更新。缺点:
    - 无法处理循环引用
    - 必须要在引用发生时对引用计数正确增减
    - 不适合并行处理

改良方式：
- 分代回收(Generational GC): 大部分对象都会在短时间内成为垃圾,经过一定时间依然存活的对象用有较长的寿命。
老生代对新生代的引用放到记录集（remembered set）。小回收和大回收。写屏障

- 增量回收(Incremental GC):为了维持程序的实时性，不等到GC全部回收完成，而是将GC操作细分成多个部分逐一执行。
写屏障:当已经被标记的对象的引用关系发生变化时，通过写屏障会将新被引用的对象作为扫描的起点记录下来

- 并行回收:在原有程序运行的同时进行GC操作。

2.5 异常处理
正常化偏见


2.6 闭包
函数对象
高阶函数：利用函数作为参数的函数
作用域（Scope）：变量的有效范围，某个变量可以被访问的范围。从函数对象中能够对外部变量进行访问（引用、更新），是闭包构成条件之一。
生存期（Extent）：变量的寿命。一个变量可以在多长周期范围内存在并能够被访问。
闭包：属于外部作用域中的局部变量，被函数对象给『封闭』在里面了。被封闭起来的变量的寿命，与封闭它的函数对象寿命相等。当封闭这个变量的函数对象不再被访问，
被垃圾回收器回收时，这个变量的寿命也就同事终结了。
在函数对象中，将局部变量这一环境封闭起来的结构被称为闭包。

3章：编程语言新潮流
3.1:
类型：指的是对某个数据所具有的性质的描述
结构子类型（structural subtyping）：以类型的结构来确定可代换性的类型关系。golang采取的方式，同时具有鸭子类型和静态类型的优点


3.2 Go


4章：云计算时代的编程
4.1 可扩展性
boolm过滤器
DHT（分布式散列表）:

4.2 C10K 问题
epoll: 监视的 fd 没有限制，内核会记忆要监视的 fd，无需每次都初始化；只返回产生事件的 fd 的信息，无需遍历所有的 fd
epoll_create: 创建监视描述符
epoll_ctl: 将监视描述符进行注册
epoll_wait: 监视

libev: 提供高性能事件循环的库，跨平台


4.3 HashFold

OOM Killler(Out of Memory Killer)

4.4 进程间通信

同一台计算机中间的进程通信：管道pipe, 消息,信号量(semaphore)，共享内存，tcp套接字，udp套接字，unix域套接字
unix域套接字使用和文件一样的路径指定连接目标。以路径作为连接目标，就意味着unix域套接字只能用于同一台计算机上的进程间通信。不过它不仅可以传输一般的字节流，
还可以传输文件描述符。

4.5 Rack 与 Unicorn


5章：支持大数据的数据存储技术
5.1  键值存储
RDBMS:
Atomicity: 对数据的操作只允许全部完成或者完全未做改变这两种状态
Consistency: 数据库的状态必须永远满足给定的条件。比如如果存款大于0，一定是可以取出来钱的。
Isolation: 保持原子性的一系列操作的中间状态，不能由其他事务进行干涉。
Durability:当保持原子行的一系列操作完成时，其结果会被保存并不会丢失。

CAP 原理：ACID是不可扩展的，RDBMS在大规模环境中无法达到期望值
Consistency(一致性)
Availabiliy(可用性) ： 一般不能舍弃
Partition Tolerance(分区容忍性)
最多满足两个。

单一故障点：分布式系统中，局部故障导致整体故障

BASE(
Basically Avaiable
Soft-state
Eventually consistent
)

5.2 NoSQL
RDB的极限：
键值数据库
面向文档: couchDb, mongoDB
面向对象


6章：多核时代的编程
超线程：通过处理多个取出并执行指令的控制流程，从而将没有相互依赖关系的运算同时送入运算器中，通过这一手段
可以提高超标量的利用效率
摩尔定律已经接近极限。


6.2 UNIX管道
管道：将文件定义为基本的字节流
阿姆达尔定律：(通过并行计算所获得的)系统性能提升效果，会随着无法并行的部分产生饱和。因此只靠多核无法解决所有的问题。


6.3 非阻塞I/O
事件驱动模型。
缓冲机制中两种情况会发生阻塞：
1. 当缓冲区为空的时候，需要等待数据到达缓冲区（读取时）
2. 另一种是当缓冲区满的时候，需要等待缓冲区腾出空间（写入时）
非阻塞IO：

6.4 node.js

如何提升效率：
减负: 采用更好的算法、减少无用的开销、用空间来换时间
拖延: 利用人心理上的弱点。
委派: 多核的困难（任务分割、通信开销、可靠性）将工作分成异步子任务是提高效率的关键

事件驱动编程：对来自外部的事件进行响应，并调用与改时间相对应的『回调函数』，主循环一般使用一个循环程序来等待实事件的发生。
当回调函数运行完毕后，再次返回到循环中，等待下一个实践。

6.5 ZeroMQ
通信模型：
REQ/RES  (http,rpc)
PUB/SUB
PUSH/PULL
