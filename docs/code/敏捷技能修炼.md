# 1.意图导向编程
意图导向编程是指：先假设当前这个对象中已经有了一个理想方法，它可以准确无误完成你想做的事情，而不是直接盯着每一点要求编写代码。
·
# 2.分离构造和使用
任何时候引用对象，都应该封装它涉及的具体实现。
将对象的创建和使用分离开

# 3.代码未动，测试先行
考虑代码的测试性刻意创建出一个更好的设计方案。


# 4. Shalloway 法则和 Shalloway 原则
如果代码中有 N 个地方需要修改，并且 N > 1 ，Shalloway 最多只能找到其中的 N-1 个地方。

冗余（具备相似或者重复的特征）的种类:
- 复制粘贴
- 幻数
- 其他类型：冗余行为、冗余信息、冗余实现

# 5. 封装
所有隐藏起来的部分，我们都是可以改变的
把困难封装起来

# 6. 面向接口的设计
专注于对象所提供的服务或模块的职责，而不是他们的具体实现。
接口是与其他实体（可能是一个方法、类、一个模块、或一段程序）交互的方式， 常见形式：
- 一个对象可调用方法的集合
- 一种协议（FTP等）
- 一种程序接口，比如 web 服务

接口约定：每个接口都应当具备明确的约定，包含前置条件和后置条件。
- 前置条件：开始执行某种操作时，认为肯定正确的东西。
- 后置条件：操作结束时，应该完成的东西

接口三大定律：
- 实现应当正确完成它的方法宣称的事情（对应功能测试）
- 接口的实现不得损害系统（对应能力测试）
- 如果不能实现相关职责，必须通知相关调用者,使用错误代号或者异常(负面功能测试)

委派优于继承

# 7. 验收测试驱动开发

- 通过用户界面创建一个调用业务规则的事务
- 开发一个用户界面，并通过这个界面直接董啊用业务规则
- 通过某种语言的单元测试框架实现测试
- 通过自动化的测试用例直接与业务规则模块交互

# 8. 避免过度设计或者设计不足
这种的办法：花足够多的时间提高代码质量，但别花一秒时间去做你目前根本不需要要的功能

代码质量病理学，五种常见的质量分类
- 内聚：内聚涉及两个概念：高内聚的类（内部功能相互关联度搞）；内聚的方法（只做一件事）
- 适当耦合：对象之间的关系定义良好
- 没有冗余：在一个地方修改了代码，在别的地方也必须做出相应的改变
- 可读性：表露意图
- 封装：病理特征：你必须知道正在使用的内部代码是什么，否则无法正确使用它

# 9. 持续集成
持续集成意味着每次代码改动结束，就要立即把这个改动提交到主干并把这件事通知到所有人，把改动合并到他们的分之。

# 10. 共性和可变性分析
共性分析：识别由于其所在环境或者具备的功能相互牵连，关联在一起的因素
可变性分析：只有在给定共性的前提下，可变性才有意义。由具体类型实现
共性分析涉及问题领域的概念层面，可变性分析涉及实现层面（具体用例）。
两个简单的问题帮助找出概念和变体：
- 这是概念还是实现？
- 如果它是概念，它的变体是什么？如果它是实现，它是什么的变体？

分析矩阵：针对问题领域的概念模型设计
- 1.选择一个将要描述的特定用例
- 2.列出完成这个用例所需要的步骤，把第一步放在最上面，后面的步骤依次排列
- 3.在每个步骤的左边创建一列
- 4.把每一个步骤的概念和意义写在左边的列里


# 11. 以开闭原则为目标的重构
软件中的实体（类、模块、函数等），应该满足对扩展是开放的，对修改是封闭的
组织代码最基本和通用的方法：使用具备良好粒度的函数


# 12. 需求与功能接口
函数和方法的迪米特法则: 一个方法M存在一个对象 O 中，对象 O 的 M 方法只引用下面几种对象的方法：
- 对象 O 的其他方法
- M 的参数
- 在M 方法中被实例化的对象
- O 所包含的子对象
- 任何 O 可以访问的全局变量

# 13. 何时以及如何使用继承
优先使用组合而非继承
通过继承来隐藏变量，而不是代码复用

# 高质量代码（容易理解、可以测试、便于修改）:

#### 内聚
- 描述：类或者方法中的所有元素都相互关联，不含有不相关的元素
- 原则：单一职责原则、关注点分离
- 实践：意图导向编程、测试先行、共性和可变性分析
- 病理症状：臃肿的类（太多职责）、冗长方法（包含多个功能）、难以命名（内聚性不强、不好命名）
- 测试中的迹象：臃肿的测试用例、多个原因导致测试失败

#### 耦合(一个给定实体与其他实体之间的依赖是符合逻辑、显而易见和最小化的)

- 描述：
    - 本体耦合：一种类型和另一种已存在的类型发生关联，比如 ClassA 的方法返回了 ClassB 的一个引用
    - 表象耦合：一种类型与另一种类型的接口发生关联的时候。
    - 继承耦合：派生类和基类之间的关联关系，基类发生变化，子类也会发生变化
    - 子类耦合：关联到某个类型具备多态的时候

- 原则：开闭原则
- 实践：封装，仅在需要的时候暴露细节；针对接口设计；继承是针对可插入性（系统应该能比较容易把一个类抽出去，同时将另一个同样接口的类加进来）
- 病理症状：边界效应
- 测试中的迹象：缓慢复杂的测试；大量的测试准备


#### 冗余
- 描述：任何东西，只要它有可能变化，就改在系统中找到一个单独且唯一的地方放起来。
- 原则：一种规则对应一个地方；DRY；shalloway法则
- 实践：出现冗余后马上重构；测试先行
- 病理症状：多个客户端发现重复
- 测试中的迹象：测试中的冗余


#### 封装
- 描述：把能藏的东西都藏起来（数据、状态、行为、类型、内存分配、使用顺序、接口、实体、子系统）
- 原则：封装所有的变化
- 实践：原则上都应该封装，确实有需要的时候暴露细节
- 病例症状：系统无法继续维护
- 测试中的迹象：粗粒度测试
