<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>《go book》 - ZWiley的读书笔记</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.0.4, mkdocs-gitbook-1.0.7">
<meta name="author" content="ZWiley">
<link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../../../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href="../../.." target="_blank" class="custom-link">ZWiley的读书笔记</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="../../..">简介</a>
<li class="header">C++</li>

<li>
<a href="../../../基础语言/C++编译底层/" class="">《C++编译底层》</a>
</li>

<li>
<a href="../../../基础语言/C++基础知识/" class="">《C++基础知识》</a>
</li>

<li>
<a href="../../../基础语言/C++智能指针_异常机制_强制转换_RTTI/" class="">《C++智能指针》</a>
</li>

<li>
<a href="../../../基础语言/C++面向对象/" class="">《C++面向对象》</a>
</li>

<li>
<a href="../../../基础语言/STL/" class="">《C++ STL》</a>
</li>

<li class="header">计算机基础知识</li>

<li>
<a href="../../../计算机基础知识/操作系统/" class="">《操作系统》</a>
</li>

<li>
<a href="../../../计算机基础知识/计算机网络/" class="">《计算机网络》</a>
</li>

<li>
<a href="../../../计算机基础知识/数据结构/" class="">《数据结构》</a>
</li>

<li>
<a href="../../../计算机基础知识/海量数据处理/" class="">《海量数据处理》</a>
</li>

<li class="header">《基本手写代码》</li>

<li>
<a href="../../../基本手写代码/插入排序.cpp" class="">《插入排序》</a>
</li>

<li>
<a href="../../../基本手写代码/单例模式.cpp" class="">《单例模式》</a>
</li>

<li>
<a href="../../../基本手写代码/堆排序.cpp" class="">《堆排序》</a>
</li>

<li>
<a href="../../../基本手写代码/二分查找法.cpp" class="">《二分查找法》</a>
</li>

<li>
<a href="../../../基本手写代码/非递归二叉树遍历.cpp" class="">《非递归二叉树遍历》</a>
</li>

<li>
<a href="../../../基本手写代码/归并排序.cpp" class="">《归并排序》</a>
</li>

<li>
<a href="../../../基本手写代码/快速排序.cpp" class="">《快速排序》</a>
</li>

<li>
<a href="../../../基本手写代码/智能指针的设计与实现.cpp" class="">《智能指针的设计与实现》</a>
</li>

<li class="header">项目基础知识</li>

<li>
<a href="../../../项目基础知识/Linux系统编程及基本命令/" class="">《Linux系统编程及基本命令》</a>
</li>

<li>
<a href="../../../项目基础知识/MySQL/" class="">《MySQL》</a>
</li>

<li>
<a href="../../../项目基础知识/Redis/" class="">《Redis》</a>
</li>

<li>
<a href="../../../项目基础知识/Socket编程/" class="">《Socket编程》</a>
</li>

<li class="header">代码</li>

<li>
<a href="../../../code/work_with_legacy_code/" class="">《Work with legacy code》</a>
</li>

<li>
<a href="../../../code/代码大全/" class="">《代码大全》</a>
</li>

<li>
<a href="../../../code/代码的未来/" class="">《代码的未来》</a>
</li>

<li>
<a href="../../../code/基本功/" class="">《基本功》</a>
</li>

<li>
<a href="../../../code/敏捷技能修炼/" class="">《敏捷技能修炼》</a>
</li>

<li>
<a href="../../../code/程序员应该知道的97件事/" class="">《程序员应该知道的97件事》</a>
</li>

<li>
<a href="../../../code/编写可读代码的艺术/" class="">《编写可读代码的艺术》</a>
</li>

<li>
<a href="../../../code/编程匠艺/" class="">《编程匠艺》</a>
</li>

<li>
<a href="../../../code/领域驱动设计/" class="">《领域驱动设计》</a>
</li>

<li>
<a href="../../../code/codelife_不止代码/" class="">《codelife_不止代码》</a>
</li>

<li class="header">调试技术</li>

<li>
<a href="../../../debug/软件调试修炼之道/book/" class="">《软件调试修炼之道》</a>
</li>

<li>
<a href="../../../debug/Effective_Debugging/" class="">《Effective Debugging》</a>
</li>

<li class="header">数据库</li>

<li>
<a href="../../../database/getting_started_with_impala/" class="">《Getting started with impala》</a>
</li>

<li>
<a href="../../../database/mysql必知必会/" class="">《mysql必知必会》</a>
</li>

<li>
<a href="../../../database/mysql性能调优与架构实践/" class="">《mysql性能调优与架构实践》</a>
</li>

<li>
<a href="../../../database/Mysql技术内幕InnoDB存储引擎/" class="">《Mysql技术内幕InnoDB存储引擎》</a>
</li>

<li>
<a href="../../../database/redis实战/" class="">《Redis实战》</a>
</li>

<li>
<a href="../../../database/redis深度历险核心原理和应用实践/book/" class="">《Redis深度历险核心原理和应用实践》</a>
</li>

<li>
<a href="../../../database/redis设计与实现/" class="">《redis设计与实现》</a>
</li>

<li>
<a href="../../../database/七周七数据库/" class="">《七周七数据库》</a>
</li>

<li>
<a href="../../../database/深入浅出mysql/" class="">《深入浅出mysql》</a>
</li>

<li>
<a href="../../../database/高性能mysql第三版/" class="">《高性能mysql第三版》</a>
</li>

<li class="header">前端</li>

<li>
<a href="../../../frontend/CSS_The_Missing_Manual/" class="">《CSS_The_Missing_Manual》</a>
</li>

<li>
<a href="../../../frontend/reactjs_小书/" class="">《reactjs小书》</a>
</li>

<li>
<a href="../../../frontend/es6标准入门/" class="">《ES6标准入门》</a>
</li>

<li>
<a href="../../../frontend/jquery_pocket_reference/" class="">《jquery_pocket_reference》</a>
</li>

<li>
<a href="../../../frontend/深入理解bootstrap/" class="">《深入理解bootstrap》</a>
</li>

<li class="header">golang</li>

<li>
<a href="../../1_the_go_programming_lauguage/" class="">《1 The Go Programming Language》</a>
</li>

<li>
<a href="../../2_the_go_programming_lauguage/" class="">《2 The Go Programming Language》</a>
</li>

<li>
<a href="../../3_the_go_programming_lauguage/" class="">《3 The Go Programming Language》</a>
</li>

<li>
<a href="../../build-web-application-with-golang/" class="">《Build Web Application With Golang》</a>
</li>

<li>
<a href="../../go101/book/" class="">《Go101》</a>
</li>

<li>
<a href="../../network-programming-with-go/book/" class="">《Network Programming with go》</a>
</li>

<li>
<a href="../../building-microservices-with-go/book/" class="">《Building Microservices With Go》</a>
</li>

<li>
<a href="../../building_restful_web_services_with_go/book/" class="">《Building Restful Web Services with Go》</a>
</li>

<li>
<a href="../../concurrency-in-go/concurrency_in_go/" class="">《Concurrency In Go》</a>
</li>

<li>
<a href="../../go_in_action(go语言实战)/" class="">《Go In Action(Go 实战)》</a>
</li>

<li>
<a href="../../go语言学习笔记语言详解/" class="">《Go学习笔记语言详解》</a>
</li>

<li>
<a href="../../go语言学习笔记源码剖析/" class="">《Go学习笔记源码剖析》</a>
</li>

<li>
<a href="../../go语言编程/" class="">《go语言编程》</a>
</li>

<li>
<a href="./" class="active">《go book》</a>
</li>

<li>
<a href="../../advanced-go-programming-book/advanced-go-programming/" class="">《advanced-go-programming》</a>
</li>

<li>
<a href="../../go-build-web-applications/module1/go-build-web-applications/go-build-web-applications/" class="">《go-build-web-applications》</a>
</li>

<li class="header">java</li>

<li>
<a href="../../../java/java-basic-introduction/" class="">《java basic introduction》</a>
</li>

<li class="header">网络</li>

<li>
<a href="../../../network/tcp_ip详解卷一/tcp_ip详解卷一/" class="">《TCP IP详解卷一》</a>
</li>

<li class="header">python</li>

<li>
<a href="../../../python/fluent_python/" class="">《Fluent Python》</a>
</li>

<li>
<a href="../../../python/Python_Microservices_Development/" class="">《Python Microservices Development》</a>
</li>

<li>
<a href="../../../python/high_performance_python/" class="">《High Performance Python》</a>
</li>

<li>
<a href="../../../python/python_网络编程/" class="">《Python网络编程》</a>
</li>

<li class="header">unix/linux</li>

<li>
<a href="../../../unix_linux/Linux高性能服务器编程/Linux高性能服务器编程/" class="">《Linux高性能服务器编程》</a>
</li>

<li>
<a href="../../../unix_linux/unix编程艺术/" class="">《unix编程艺术》</a>
</li>

<li>
<a href="../../../unix_linux/unix网络编程卷一/" class="">《unix网络编程卷一》</a>
</li>

<li>
<a href="../../../unix_linux/unix编程艺术/" class="">《unix编程艺术》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/environ/" class="">《APUE environ》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/fork/" class="">《APUE fork》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/gcc/" class="">《APUE gcc》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/IO/" class="">《APUE IO》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/IPC/" class="">《APUE IPC》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/makefile/" class="">《APUE makefile》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/wait/" class="">《APUE wait》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/动态库和静态库/" class="">《APUE 动态库和静态库》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/守护进程/" class="">《APUE 守护进程》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/文件权限/" class="">《APUE 文件权限》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/系统IO函数/" class="">《APUE 系统IO函数》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/信号/" class="">《APUE 信号》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/信号2/" class="">《APUE 信号2》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/线程/线程函数/" class="">《线程函数》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/线程/线程基础/" class="">《线程基础》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/线程/线程同步/" class="">《线程同步》</a>
</li>

<li class="header">分布式</li>

<li>
<a href="../../../分布式/Kafka权威指南/" class="">《Kafka 权威指南》</a>
</li>

<li>
<a href="../../../分布式/分布式框架原理与应用/" class="">《分布式框架原理与应用》</a>
</li>

<li>
<a href="../../../分布式/大规模分布式存储系统/" class="">《大规模分布式存储系统》</a>
</li>

<li>
<a href="../../../分布式/深入分布式缓存从原理到实践/" class="">《深入分布式缓存从原理到实践》</a>
</li>

<li class="header">搜索引擎</li>

<li>
<a href="../../../搜索引擎/Elasticsearch实战/book/" class="">《Elasticsearch实战》</a>
</li>

<li class="header">容器</li>

<li>
<a href="../../../devops/玩转Kubernets-CloudMan/" class="">《玩转Kubernets》</a>
</li>

<li>
<a href="../../../devops/第一本docker书/" class="">《第一本docker书》</a>
</li>

<li class="header">开发工具</li>

<li>
<a href="../../../开发工具/practical_vim/practical_vim/" class="">《Practical Vim》</a>
</li>

<li>
<a href="../../../开发工具/vim8文本处理实战/vim8文本处理实战/" class="">《Vim8文本处理实战》</a>
</li>

<li>
<a href="../../../开发工具/learn_vim_the_hard_way/" class="">《Learn vim scrpt the hard way》</a>
</li>

<li>
<a href="../../../开发工具/pro_git/" class="">《Pro Git》</a>
</li>

<li>
<a href="../../../开发工具/Mastering_vim/" class="">《Mastering Vim》</a>
</li>

<li>
<a href="../../../开发工具/mastering_vim_quickly/" class="">《Mastering Vim Quickly》</a>
</li>

<li class="header">思维</li>

<li>
<a href="../../../思维认知/专注力_化繁为简的惊人力量/" class="">《专注力》</a>
</li>

<li>
<a href="../../../思维认知/为什么精英这样用脑不会累/" class="">《为什么精英这样用脑不会累》</a>
</li>

<li>
<a href="../../../思维认知/刻意练习/" class="">《刻意练习》</a>
</li>

<li>
<a href="../../../思维认知/如何想到又做到/" class="">《如何想到又做到》</a>
</li>

<li>
<a href="../../../思维认知/学习之道/" class="">《学习之道》</a>
</li>

<li>
<a href="../../../思维认知/学习力/" class="">《学习力》</a>
</li>

<li>
<a href="../../../思维认知/批判性思维工具/" class="">《批判性思维工具》</a>
</li>

<li>
<a href="../../../思维认知/程序员的思维修炼(开发认知潜能的九堂课)/" class="">《程序员的思维修炼》</a>
</li>

<li>
<a href="../../../思维认知/认知天性/" class="">《认知天性》</a>
</li>

<li>
<a href="../../../思维认知/超效率手册/" class="">《超效率手册》</a>
</li>

<li>
<a href="../../../思维认知/如何高效记忆/" class="">《如何高效记忆》</a>
</li>

<li>
<a href="../../../思维认知/科学学习/" class="">《科学学习》</a>
</li>

<li>
<a href="../../../思维认知/高效程序员的45个习惯/" class="">《高效程序员的45个习惯》</a>
</li>

<li class="header">源码</li>

<li>
<a href="../../../源码阅读_sourcecode/" class="">《源码阅读》</a>
</li>

<li class="header">网站架构微服务</li>

<li>
<a href="../../../网站架构微服务/microservices_patterns_微服务架构设计模式/book/" class="">《微服务架构设计模式》</a>
</li>

<li>
<a href="../../../网站架构微服务/从0开始学架构/从0开始学架构/" class="">《从0开始学架构》</a>
</li>

<li>
<a href="../../../网站架构微服务/web_scalavility_for_startup_engineers/" class="">《web scalavility for startup engineers》</a>
</li>

<li>
<a href="../../../网站架构微服务/design_data_instensive_application/" class="">《design_data_instensive_application》</a>
</li>

<li>
<a href="../../../网站架构微服务/clean_architecture/" class="">《clean_architecture》</a>
</li>

<li>
<a href="../../../网站架构微服务/微服务设计/" class="">《微服务设计》</a>
</li>

<li>
<a href="../../../网站架构微服务/2_design_data_instensive_application/" class="">《2_design_data_instensive_application》</a>
</li>

<li>
<a href="../../../网站架构微服务/3_design_data_instensive_application/" class="">《3_design_data_instensive_application》</a>
</li>

<li class="header">软件工程/项目管理</li>

<li>
<a href="../../../软件工程_项目管理/人月神话/" class="">《人月神话》</a>
</li>

<li>
<a href="../../../软件工程_项目管理/代码之殇/" class="">《代码之殇》</a>
</li>

<li>
<a href="../../../软件工程_项目管理/解析极限编程-拥抱变化/" class="">《解析极限编程》</a>
</li>

<li>
<a href="../../../软件工程_项目管理/项目管理修炼之道/" class="">《项目管理修炼之道》</a>
</li>

<li>
<a href="../../../软件工程_项目管理/修改软件的艺术/" class="">《修改软件的艺术》</a>
</li>

<li class="header">运维</li>

<li>
<a href="../../../运维/linux集群和自动化运维/" class="">《linux集群和自动化运维》</a>
</li>

<li>
<a href="../../../运维/python自动化运维/" class="">《python自动化运维》</a>
</li>

<li class="header">金融理财</li>

<li>
<a href="../../../金融理财/定投十年/" class="">《定投十年》</a>
</li>

<li>
<a href="../../../金融理财/穷查理宝典/" class="">《穷查理宝典》</a>
</li>

<li class="header">写作</li>

<li>
<a href="../../../写作/刷屏文案写作技巧/" class="">《刷屏文案写作技巧》</a>
</li>

<li class="header">互联网</li>

<li>
<a href="../../../互联网/我的互联网方法论-周鸿祎/" class="">《我的互联网方法论-周鸿祎》</a>
</li>

<li>
<a href="../../../互联网/用户思维/" class="">《用户思维》</a>
</li>

<li class="header">区块链</li>

<li>
<a href="../../../区块链/区块链技术指南(blockchain_guide)/" class="">《区块链技术指南》</a>
</li>

<li class="header">技术演讲</li>

<li>
<a href="../../../lecture/Gopher/哔哩哔哩的go微服务实战/note/" class="">《哔哩哔哩的go微服务实战》</a>
</li>

<li>
<a href="../../../lecture/Gopher/Go_Error/go业务基础库之Error&Context/" class="">《go业务基础库之Error&Context》</a>
</li>

<li>
<a href="../../../lecture/Gopher/Go同步和并发设计模式/note/" class="">《Go同步和并发设计模式》</a>
</li>

<li>
<a href="../../../lecture/技术演讲/左耳朵耗子-我这技术二十年/" class="">《左耳朵耗子-我这技术二十年》</a>
</li>

<li class="header">职场</li>

<li>
<a href="../../../career/give_and_take/" class="">《give and take》</a>
</li>

<li>
<a href="../../../career/the_effective_engineer/" class="">《the_effective_engineer》</a>
</li>

<li>
<a href="../../../career/光速成长/" class="">《光速成长》</a>
</li>

<li>
<a href="../../../career/向上管理/" class="">《向上管理》</a>
</li>

<li>
<a href="../../../career/成功动机与目标/" class="">《成功动机与目标》</a>
</li>

<li>
<a href="../../../career/番茄工作法/" class="">《番茄工作法》</a>
</li>

<li>
<a href="../../../career/聆听沟通学/" class="">《聆听沟通学》</a>
</li>

<li>
<a href="../../../career/知乎职人觉醒/" class="">《知乎职人觉醒》</a>
</li>

<li>
<a href="../../../career/知识变现/" class="">《知识变现》</a>
</li>

<li>
<a href="../../../career/聆听沟通学/" class="">《聆听沟通学》</a>
</li>

<li>
<a href="../../../career/职场动物进化手册/" class="">《职场动物进化手册》</a>
</li>

<li>
<a href="../../../career/职场解释系/" class="">《职场解释系》</a>
</li>

<li>
<a href="../../../career/请停止无效努力/" class="">《请停止无效努力》</a>
</li>

<li>
<a href="../../../career/软技能/" class="">《软技能》</a>
</li>

<li>
<a href="../../../career/高效15法则/" class="">《高效15法则》</a>
</li>

<li>
<a href="../../../career/高效清单工作法/" class="">《高效清单工作法》</a>
</li>

<li>
<a href="../../../career/程序员的自我修养/" class="">《程序员的自我修养》</a>
</li>

<li class="header">心理学</li>

<li>
<a href="../../../psychology/一切都是童年的错吗/" class="">《一切都是童年的错吗》</a>
</li>

<li>
<a href="../../../psychology/亲密关系/" class="">《亲密关系》</a>
</li>

<li>
<a href="../../../psychology/情商/" class="">《情商》</a>
</li>

<li>
<a href="../../../psychology/拖延心理学/" class="">《拖延心理学》</a>
</li>

<li>
<a href="../../../psychology/积极心理学/" class="">《积极心理学》</a>
</li>

<li>
<a href="../../../psychology/自控力/" class="">《自控力》</a>
</li>

<li>
<a href="../../../psychology/自控力-和压力做朋友/" class="">《自控力:和压力做朋友》</a>
</li>

<li>
<a href="../../../psychology/活出最乐观的自己/" class="">《活出最乐观的自己》</a>
</li>

<li>
<a href="../../../psychology/改变心理学的40项研究/" class="">《改变心理学的40项研究》</a>
</li>

<li>
<a href="../../../psychology/超越自卑/" class="">《超越自卑》</a>
</li>

<li>
<a href="../../../psychology/反脆弱/" class="">《反脆弱》</a>
</li>

<li class="header">创业</li>

<li>
<a href="../../../startup/hello_startup/" class="">《Hello Startup》</a>
</li>

<li>
<a href="../../../startup/斯坦福公开课-如何创业/" class="">《斯坦福公开课如何创业》</a>
</li>

<li>
<a href="../../../startup/运营其实很简单/" class="">《运营其实很简单》</a>
</li>

<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="11-interfaces-and-reflection">11 Interfaces and reflection</h1>
<p>An Interface define a set of methods. And cannot contain variables.</p>
<pre><code class="go">type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
}
</code></pre>

<h2 id="113-type-assertion">11.3 type assertion</h2>
<pre><code class="go">if v, ok := varI.(T); ok {
//
}
</code></pre>

<p>Value-received methods can be called with pointer values because they can be dereference first.</p>
<pre><code class="go">package sort

type Sorter interface {
    Len() int
    Less(i, jint) bool
    Swap(i, j int)
}

fucn Sort(data Sorter) {
    for pass := 1; pass &lt;data.Len(); pass ++ {
        for i :=0; i &lt; data.Len()-pass; i++ {
            if data.Less(i+1,i) {
                data.Swap(i,i+1)
            }
        }
    }
}

func IsSorted(data Sorter) bool {
    n := data.Len()
    for i := n-1; i &gt;0; i-- {
        if data.Less(i, i-1){
            return false
        }
    }
    return true
}

// convenience types for common cases

type IntArray []int
func (p IntArray) Len() int {return len(p)}
func (p IntArray) Less(i,j int) bool {return p[i] &lt; p[j]}
func (p IntArray) Swap(i,j int) {p[i],p[j] = p[j],p[i]}
</code></pre>

<h3 id="1192-contsucting-an-array-of-a-general-type-or-with-variables-of-different-types">11.9.2 contsucting an array of a general type or with variables of different types</h3>
<pre><code class="go">type Element interface{}

type Vector struct {
    a []Element
}

func (p *Vector) At(i int) Element {
    return p.a[i]
}

func (p *Vector) Set(i int, Element e) {
    p.a[i] = e
}
</code></pre>

<p>tree struct:</p>
<pre><code class="go">package main

import &quot;fmt&quot;

type Node struct {
    le   *Node
    data interface{}
    ri   *Node
}

func NewNode(left, right *Node) *Node {
    return &amp;Node{left, nil, right}
}

func (n *Node) SetData(data interface{}) {
    n.data = data
}

func main() {
    root := NewNode(nil, nil)
    root.SetData(&quot;root node&quot;)
    a := NewNode(nil, nil)
    a.SetData(&quot;left node&quot;)
    b := NewNode(nil, nil)
    b.SetData(&quot;right node&quot;)
    root.le = a
    root.ri = b
    fmt.Printf(&quot;%v\n&quot;, root)
}
</code></pre>

<h2 id="1110-the-reflect-package">11.10 The reflect package</h2>
<h2 id="1114-structs-coolections-and-higher-order-functions">11.14 Structs coolections and higher order functions</h2>
<pre><code class="go">package main

type Any interface{}

type Car struct {
    Model        string
    Manufacturer string
    BuildYear int
}

type Cars []*Car

func (cs Cars) Map(f func(car *Car) Any) []Any {
    result := make([]Any, 0)
    ix := 0
    cs.Process(func(c *Car) {
        result[ix] = f(c)
        ix++
    })
    return result
}

allNewBMWs := allCars.FindAll(func(car *Car) bool {
    return (car.Manufacturer == &quot;BMW&quot;) &amp;&amp; (car.BuildYear &gt; 2010)
})
</code></pre>

<h1 id="12-reading-and-writing">12 Reading and writing</h1>
<pre><code class="go">// read input from console:
package main

import &quot;fmt&quot;

var (
    firstName, lastName string
)

func main() {
    fmt.Scanln(*firstName, *lastName)
    fmt.Println(&quot;Hi %s %s\n&quot;, &amp;firstName, &amp;lastName)
}

// or use bufio.Reader
</code></pre>

<h1 id="13-error-handling-and-testing">13 Error-handling and Testing</h1>
<p>no try/catch, defer-panic-and-recover mechanism.</p>
<pre><code class="go">type error interface {
    Error() string
}
// to stop an error-state program, use os.Exit(1)


// define new errors
err := errros.New(&quot;math-square root of negative number&quot;)

// custome error field
type PathError struct {
    Op   string
    Path string
    Err  error
}
func ( e *PathError) String() string {
    return e.Op + &quot; &quot; + e.Path = &quot;: &quot; + e.Err.Error()
}
// making errror-object with fmt
if f &lt; 0 {
    return 0, fmt.Errorf(&quot;math: square root of negative number %g&quot;, f)
}
</code></pre>

<h2 id="132-run-time-exceptions-and-panic">13.2 Run-time exceptions and panic</h2>
<p>if panic is called from a nested function, immediately stops the execution of the current function,
all defer statement are guaranteed to execute and the control is given to the function caller, which receives this call
to panic.</p>
<h2 id="133-recover">13.3 Recover</h2>
<p>recover is only useful when called inside a deferred function: it then retrieves the error value passed through the call
of panic; when used in normal execution a call to recover will return nil and have no other effects.</p>
<p>like catch in java.</p>
<pre><code class="go">func protect(g func()) {
    defer func() {
        log.Println(&quot;done&quot;)
        if err := recover(); err != nil {
            log.Printf(&quot;run time panic : %v&quot;, err)
        }
    }()
    log.Println(&quot;start&quot;)
    g()
}


package main

import &quot;fmt&quot;

func badCall() {
    panic(&quot;bad end&quot;)
}

func test() {
    defer func() {
        if e := recover(); e != nil {
            fmt.Printf(&quot;Panicking %s\r\n&quot;, e)
        }
    }()
    badCall()
    fmt.Printf(&quot;After bad call\r\n&quot;)
}

func main() {
    fmt.Printf(&quot;calling test\r\n&quot;)
    test()
    fmt.Printf(&quot;calling test end\r\n&quot;)
}
</code></pre>

<h2 id="134-error-handling-and-panicking-in-a-custom-package">13.4 Error-handling and panicking in a custom package</h2>
<p>best practice:</p>
<ul>
<li>always recover from panic in your package: no explicit panic() should be allowed to cross a package boundary</li>
<li>return errors as error values to the callers of your package.</li>
</ul>
<h2 id="135-an-error-handling-scheme-with-closures">13.5 An Error-handling scheme with closures</h2>
<pre><code class="go">func f(a type1, b type2)

fType1 = func f(a type1, b type2)


func errorHandler(fn fType1) fType1 {
    return func(a type1, b type2) {
        defer func() {
            if e, ok := recover().(error); ok {
                log.Printf(&quot;run time panic:%v&quot;, err)
            }
        }()
        fn(a,b)
    }
}

</code></pre>

<h2 id="136-starting-an-external-command-or-program">13.6 Starting an external command or program</h2>
<p>os.StartProcess
exec.Command(name string, arg ...string)</p>
<h2 id="137-testing-and-benckmarking-in-go">13.7 Testing and benckmarking in GO</h2>
<h1 id="14-goroutines-and-channels">14 Goroutines and channels</h1>
<h2 id="141-concurrency-parallelism-and-goroutines">14.1 Concurrency, parallelism and goroutines</h2>
<p>CSP(Communicating Sequentiadl Processes)</p>
<p>parallelism is the ability to make things run quickly by using multiple processors.</p>
<p>An experiential rule of thumb seems to be that for n cores setting GOMAXPROCS to n-1 yields the best the performance,
and the following should also be followed: number of goroutines &gt; 1 + GOMAXPROCS &gt; 1</p>
<p>If we do not wai int main(), the program stop the goroutines die with it.
When the func main() returns, the program exits, it does not wait for other (non-main) goroutines to complete.
The logic of your code must be independent of the order in which goroutines are invoked.</p>
<h3 id="1415">14.1.5</h3>
<p>difference bewteen goroutines and coroutines(c# and python):</p>
<ul>
<li>goroutines imply parallelism, coroutines in general do not</li>
<li>goroutines communicate via channels; coroutines communicate via yield and resume operations</li>
</ul>
<h2 id="142-channels-for-communication-between-goroutines">14.2 Channels for communication between goroutines</h2>
<p>Using shared variables is not discouranged.
Only one goroutine has access to a  data item at any given time: so data races cannot occur, by design. Channels a firstclass objects.</p>
<pre><code>var identifier chan datatype // uniniitialized channel is nil
var cha1 chan string // reference type
ch1 = make(chan string)
</code></pre>

<p>Channel send and receive operations are aotmic, they always complete without interruption.</p>
<h3 id="1423-blocking-of-channels">14.2.3 Blocking of channels</h3>
<p>default communication is synchronous and unbuffered: sends do not complete until there is a receiver to accept the value. So channel send/receive block until the other side is ready.</p>
<ul>
<li>A send opeartion on a channel blocks until a receiver is available. for the same channel.</li>
<li>A receive operation for a channel blocks until a sender is available for the same channel.</li>
</ul>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ch1 := make(chan int)
    go pump(ch1)
    // fmt.Println(&lt;-ch1)
    go suck(ch1)
    time.Sleep(1e9)
}

func pump(ch chan int) {
    for i := 0; ; i++ {
        ch &lt;- i
    }
}

func suck(ch chan int) {
    for {
        fmt.Println(&lt;-ch)
    }
}
</code></pre>

<h3 id="1425-asynchronous-channels-making-a-channel-with-a-buffer">14.2.5 Asynchronous channels-making a channel with a buffer</h3>
<p>An unbuffered channel can only contain 1 item and is for that reason somethimes too restrictive.</p>
<pre><code>buf := 100
ch1 := make(chan string, buf) //buf is the number of elements the channel can hold
</code></pre>

<p>sending to a bufferd channel will not blocked unless buffer is full, reading not blocked unless buffer is empty.
If the capacity is greater than 0, channel is asychronous</p>
<p>Semaphore pattern</p>
<pre><code>    ch := make(chan int)
    go func() {
        // do something
        ch &lt;- 1
    }()
    doSomethingElseForAWhile()
    &lt;-ch // wait for goroutine to finish. discard send value
</code></pre>

<h3 id="1429-implementing-a-semaphore-using-a-buffered-channel">14.2.9 Implementing a semaphore using a buffered channel</h3>
<pre><code>type Empty interface{}
type semaphore chan Empty


sem = make(semaphore, N)

// acauire n resourdces
func (s semaphore) P(n int) {
    e := new(Empty)
    for i :=0 ; i &lt; n; i ++ {
        s &lt;- e
    }
}
// release n resources
func (s semaphore) V(n int) {
    for i :=0 ;i &lt;n;i ++ {
        &lt;-s
    }
}

// mutexes
func (s semaphore) Lock() {
    s.P(1)
}
func (s semaphore) Unlock() {
    s.V(1)
}

// signal-wait
func (s semaphore) Wait(n int) {
    s.P(n)
}
func (s semaphore) Signal() {
    s.V(1)
}
</code></pre>

<h3 id="14210-for-range-applied-to-channels">14.2.10 For-range applied to channels</h3>
<p>It reads from the given channel ch until the channel is closed and then the code following for continue to execute. Obviously another goroutine must be writing to ch(otherwise the executino blocks in the for-loop) and must close ch when it's done writing.</p>
<p>producer consumer pattern:</p>
<pre><code>for {
    Consume(Product())
}
</code></pre>

<h3 id="14211-channel-directionality">14.2.11 Channel directionality</h3>
<pre><code>var send_only chan&lt;- int // channel can only receive data (&lt;-chan T)
var recv_only &lt;-chan int // channel can only send data
</code></pre>

<p>IDIOM: Pipe and filter pattern</p>
<pre><code>sendChan := make(chan int)
receiveChan := make(chan string)
go processChannel(sendChan, receiveChan)

func processChannel(in &lt;- chan int, out chan&lt;- string) {
    for inValue := range in {
        result := // process inValue
        out&lt;-result
    }
}
</code></pre>

<pre><code>// sieve primer number
package main

import &quot;fmt&quot;

func generate() chan int {
    ch := make(chan int)
    go func() {
        for i := 2; ; i++ {
            ch &lt;- i
        }
    }()
    return ch
}

func filter(in chan int, prime int) chan int {
    out := make(chan int)
    go func() {
        for {
            if i := &lt;-in; i%prime != 0 {
                out &lt;- i
            }
        }
    }()
    return out
}

func sieve() chan int {
    out := make(chan int)
    go func() {
        ch := generate()
        for {
            prime := &lt;-ch
            ch = filter(ch, prime)
            out &lt;- prime
        }
    }()
    return out
}

func main() {
    primes := sieve()
    for {
        fmt.Println(&lt;-primes)
    }
}
</code></pre>

<h2 id="143-synchronization-of-goroutine-closing-a-channel-testing-for-blocked-channels">14.3 Synchronization of goroutine: closing a channel - testing for blocked channels</h2>
<p>Only the sender should close a channel, never receiver.
Sending or Closing a closed channel causes a run-time panic.</p>
<pre><code>if v, ok := &lt;-ch; ok {
    process(v)
}
</code></pre>

<p>To do a non-blocking channel you need to use a select.
for range will automatically detect when the channel is closed.</p>
<h2 id="144-switching-between-goroutines-with-select">14.4 Switching between goroutines with select</h2>
<p>Getting the values out of dirrerent concurrently executing goroutines can be accomplisehd with
the select ekyworkd. A select is terminated when a break or return is executed in one of its cases.</p>
<ul>
<li>if all are blocked, it waits until one can proceed</li>
<li>if multiple can proceed, it choose one at random</li>
<li>when none of the channel operations can proceed and default clause is present, default is always runnable</li>
</ul>
<pre><code>// sieve primer number
package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
    &quot;time&quot;
)

func main() {
    runtime.GOMAXPROCS(2)
    ch1 := make(chan int)
    ch2 := make(chan int)

    go pump1(ch1)
    go pump2(ch2)
    go suck(ch1, ch2)
    time.Sleep(1e9)
}

func pump1(ch chan int) {
    for i := 0; ; i++ {
        ch &lt;- i * 2
    }
}

func pump2(ch chan int) {
    for i := 0; ; i++ {
        ch &lt;- i + 5
    }
}
func suck(ch1 chan int, ch2 chan int) {
    for {
        select {
        case v := &lt;-ch1:
            fmt.Printf(&quot;received on channel 1 :%d\n&quot;, v)
        case v := &lt;-ch2:
            fmt.Printf(&quot;received on channel 2 :%d\n&quot;, v)
        }
    }
}
</code></pre>

<h2 id="145-channels-timeouts-and-tickers">14.5 Channels, Timeouts and Tickers</h2>
<p>time.Ticker is an object that repeatedly sends a time value on a contained channel C at a specified time interval.</p>
<pre><code>func main() {
    ticker := time.NewTicker(interval)
    defer ticker.Stop()
    select {
    case u := &lt;-ch1:
        //...
    case v := &lt;-ch2:
        //...
    case &lt;-ticker.C:
        logState(status) // call some logging function logState
    default: // novalue ready to be received
        //...
    }
}
</code></pre>

<p>rate limiter:</p>
<pre><code>rate_per_sec := 10
var dur Dration = 1e9
chRate := time.Tick(dur)
for req := range requests {
    &lt;- chRate
    go client.Call(&quot;service.Method&quot;, req, ...)
}
</code></pre>

<p>time.After(d) only send time once:</p>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    tick := time.Tick(1e8)
    boom := time.After(5e8)
    for {
        select {
        case &lt;-tick:
            fmt.Println(&quot;tick.&quot;)
        case &lt;-boom:
            fmt.Println(&quot;Boom.&quot;)
            return
        default:
            fmt.Println(&quot;     .&quot;)
            time.Sleep(5e7)
        }
    }
}
</code></pre>

<h2 id="146-using-recover-with-goroutines">14.6 Using recover with goroutines</h2>
<pre><code>func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err !=nil {
            log.Printf(&quot;work faield with %s in %v:&quot;, err, work)
        }
    }()
    do(work)
}
</code></pre>

<h3 id="147-tasks-and-worker-processes">14.7 Tasks and Worker processes</h3>
<pre><code>// Master-worker paradigm
func Worker(in, out chan *Task){
    for {
        t := &lt;-in
        process(t)
        out &lt;- t
    }
}
</code></pre>

<p>when to use: a sync.Mutex or a channel?</p>
<ul>
<li>use locking(mutexes) when:
    - caching information in a shared data structure
    - holding state information, that is context or status of the running application</li>
</ul>
<ul>
<li>use channels when:
    - communicating asynchronous results
    - distributing units of work
    - passing owership of data</li>
</ul>
<h2 id="148-implementing-a-lazy-generator">14.8 Implementing a lazy generator</h2>
<p>A generator is a function that returns the next value in a sequence each time the function is called.</p>
<pre><code>package main

import (
    &quot;fmt&quot;
)

var resume chan int

func intergers() chan int {
    yield := make(chan int)
    count := 0
    go func() {
        for {
            yield &lt;- count
            count++
        }
    }()
    return yield
}
func generateInteger() int {
    return &lt;-resume
}
func main() {
    resume = intergers()
    fmt.Println(generateInteger())
    fmt.Println(generateInteger())
    fmt.Println(generateInteger())
}
</code></pre>

<h2 id="149-implementing-futures">14.9 Implementing Futures</h2>
<p>future: somtimes you know yopu need to compute a value before you need to actually use the value.
in this case, you can potentially start computing the value on another processor and have it ready
when you need it.</p>
<pre><code>func InverseProduct(a Matrix, b Matrix) {
    a_inv := Inverse(a)
    b_inv := Inverse(b)
    return Product(a_inv, b_inv)
}


/// a_inv and b_inv can compute parallel

fucn InverseProduct(a Matrix, b Matrix) {
    a_inv_future := InverseFuture(a) //. started as a goroutine
    b_inv_future := InverseFuture(b)
    a_inv := &lt;-a_inv_future
    b_inv := &lt;-b_inv_future
    return Product(a_inv,b_inv)
}

func InverseFuture(a Matrix) {
    future := make(chan Matrix)
    go func() { future&lt;-Inverse(a) } () // launched a closure as a goroutine
    return future
}
</code></pre>

<h2 id="1410-multiplexing">14.10 Multiplexing</h2>
<h2 id="1411-limiting-the-number-of-requests-processed-concurrently">14.11 Limiting the number of requests processed concurrently</h2>
<h2 id="1412-chaining-goroutines">14.12 Chaining goroutines</h2>
<h2 id="1413-parallelzing-a-computation-over-a-number-of-cores">14.13 Parallelzing a computation over a number of cores</h2>
<pre><code>func DoAll() {
    sem := make(chan int, NCPU)
    for i := 0; i &lt; NCPU; i ++ {
        go DoPart(sem)
    }
    // Drain the channel sem, waiting for  NCPU tasks to complete
    for i:= 0; i &lt; NCPU; i ++ {
        &lt;-sem
    }
    // All done
}

func DoPart(sem chan int) {
    // do the part of the computation
    sem &lt;- 1 // signal that thie piece is done
}

func main() {
    runtime.GOMAXPROCS = NCPU
    DoAll()
}
</code></pre>

<h2 id="1414-parallelizing-a-computation-over-a-large-amount-of-data">14.14 Parallelizing a computation over a large amount of data</h2>
<p>a number of steps: Preprocess / StepA / StepB / ... / PostProcess</p>
<p>pipelining algorithm:</p>
<pre><code>func SerialProcessData(in &lt;- chan *Data, out &lt;- chan *Data) {
    for data := range in {
        tmpA := PreprocessData(data)
        tmpB := ProcessStepA(tmpA)
        tmpC := ProcessStepA(tmpB)
        out &lt;- PostProcess(tmpC)
    }
}

func ParallelProcessData(in &lt;- chan  *Data, out &lt;- chan *Data) {
    // make channels:
    preOut := make(chan *Data, 100)
    stepAOut := make(chan *Data, 100)
    stepBOut := make(chan *Data, 100)
    stepCOut := make(chan *Data, 100)
    // start parallel computations
    go PreprocessData(in, preOut)
    go ProcessStepA(preOut, stepAOut)
    go ProcessStepB(stepAOut, stepBOut)
    go ProcessStepC(stepBOut, stepCOut)
    go PostProcessData(stepOut, out)
}
</code></pre>

<h2 id="1415-the-leaky-bucket-algorithm">14.15 The leaky bucket algorithm</h2>
<pre><code>var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        select {
        case b = &lt;-freeList:
            // Got one; nothing more todo
        default:
            b = new(Buffer)
            loadInto(b) // read next message from the network
        }
        serverChan &lt;- b //send to server
    }
}

func server() {
    for  {
        b := &lt;-serverChan // wait for work
        process(b)
        // reuse buffer is threre's room
        select {
        case freeList &lt;- b:
            // Reuse buffer if free slot on freeList; nothing more to do
        default:
            // freeList is full, just carry on : the buffer is 'dropped'
            // doesn't work when freeList is full, leaky bucket
        }
    }

}
</code></pre>

<h2 id="1416-benchmarking-goroutines">14.16 Benchmarking goroutines</h2>
<h2 id="1417-concurrent-access-to-object-using-a-chnnel">14.17 Concurrent access to object using a chnnel</h2>
<p>To safeguard concurrent modifications of an object instead of using locking with a sync Mutex,
we can also use a backend goroutine for the sequential execution of anonymous functions.</p>
<h1 id="16-common-go-pitfalls-or-mistakes">16 Common Go Pitfalls or Mistakes</h1>
<h2 id="161-hidingshadowing-a-variable-by-misusing-short-declaration">16.1 Hiding(shadowing) a variable by misusing short declaration</h2>
<pre><code>var remeber bool = false
if somehting {
    remeber := true // use = not :=
}
// use member


func shadow() (err error) {
    x, err := check1() // x is created, err is assigned to
    if err != nil {
        return   // err correctly returned
    }
    if y, err := check2(x); err !=nil { //y and inner err are created
        return // inner err shadows err so nil is wrongly returned!
    } else {
        fmt.Println(y)
    }
    return
}

</code></pre>

<h2 id="162-misusing-strings">16.2 Misusing strings</h2>
<p>mind that strings in go(like java and python) are immutable, Do not use a + b in a for loop,
intead one should use a bytes.Buffer to accumulate string content.</p>
<pre><code>func shadow() (err error) {
    x, err := check1() // x is created, err is assigned to
    if err != nil {
        return   // err correctly returned
    }
    if y, err := check2(x); err !=nil { //y and inner err are created
        return // inner err shadows err so nil is wrongly returned!
    } else {
        fmt.Println(y)
    }
    return
}
</code></pre>

<h2 id="163-using-defer-for-closing-a-file-in-the-wrong-scope">16.3 Using defer for closing a file in the wrong scope</h2>
<p>Defer is only executed at the return of a function, not at the end of a loop or some other limited scope.</p>
<h2 id="164-confusing-new-and-make">16.4 Confusing new() and make()</h2>
<ul>
<li>for slices, maps and channels, use make</li>
<li>for arrays, structs and all value types: use new</li>
</ul>
<h2 id="165-no-need-to-pass-a-pointer-to-a-slice-to-a-function">16.5 No need to pass a pointer to a slice to a function</h2>
<h2 id="166-using-pointers-to-interface-types">16.6 Using pointers to interface types</h2>
<p>Never use a pointer to an interface type, this is already a pointer!</p>
<h2 id="167-misusing-pointers-wiht-value-types">16.7 Misusing pointers wiht value types</h2>
<h2 id="168-misusing-goroutines-and-channels">16.8 Misusing goroutines and channels</h2>
<p>Only using goroutines and channels only where concurrency is important!</p>
<h2 id="169-using-closures-with-goroutines">16.9 Using closures with goroutines</h2>
<pre><code>package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

var values = [5]int{10, 11, 12, 13, 14}

func main() {
    // version A
    for ix := range values {
        func() {
            fmt.Print(ix, &quot; &quot;)
        }()
    }
    fmt.Println()   // 0,1,2,3,4

    // version B
    for ix := range values {
        go func() {  // invoke each closure as a goroutine
            fmt.Print(ix, &quot; &quot;)
        }() // the goroutine will probably not begin executing until after the loop
    }
    fmt.Println() // 4,4,4,4,4
    time.Sleep(5e9)
    // Version C: the right way
    for ix := range values {
        go func(ix interface{}) { // invoke each closure with ix as a parameter
            fmt.Print(ix, &quot; &quot;) //ix is the evaluated at each iteration and placed on the stack of goroutine
        }(ix)
    }
    fmt.Println()  // random
    time.Sleep(5e9)
    // Version D: print out values
    for ix := range values {
        val := values[ix] // variables declared witin the body of a loop are not shared between iterations
        go func() {
            fmt.Print(val, &quot; &quot;)
        }()
    }
    time.Sleep(1e9) //10,11,12,13,14
}
</code></pre>

<h2 id="1610-bad-error-handling">16.10 Bad error handling</h2>
<p>wrap your error conditions in a closure wherever possible, like in the following example.</p>
<pre><code>// seperate error checking, error reporting, and normal program logic

func httpRequestHandler(w http.ResponseWriter, req *http.Request) {
    err := func() error {
        if req.Method != &quot;GET&quot;{
            return errors.New(&quot;expected GET&quot;)
        }
        if input := paraseInput(req); input != &quot;command&quot; {
            return errors.New(&quot;malformed command&quot;)
        }
    }()
    // other error conditions can be tested here
    if err != nil {
        w.WriteHeader(400)
        io.WriterString(w, err)
        return
    }
    doSomething() //
}
</code></pre>

<h1 id="17-go-language-patterns">17 Go Language Patterns</h1>
<h2 id="171-the-comma-ok-pattern">17.1 The comma, ok pattern</h2>
<h2 id="172-the-defer-pattern">17.2 The defer pattern</h2>
<h2 id="173-the-visibility-pattern">17.3 The visibility pattern</h2>
<h2 id="174-the-operator-pattern-and-interface">17.4 The operator pattern and interface</h2>
<p>go不支持操作符重载，可以使用函数/方法/接口 来模拟。</p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../../../js/main.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../../../search/main.js"></script>
<script src="../../../js/gitbook.min.js"></script>
<script src="../../../js/theme.min.js"></script>
</body>
</html>