<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>《advanced-go-programming》 - ZWiley的读书笔记</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.1.2, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../../../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../../../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href="../../.." target="_blank" class="custom-link">ZWiley的读书笔记</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="../../..">简介</a>
<li class="header">C++</li>

<li>
<a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E7%BC%96%E8%AF%91%E5%BA%95%E5%B1%82/" class="">《C++编译底层》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="">《C++基础知识》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6_%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2_RTTI/" class="">《C++智能指针》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="">《C++面向对象》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/STL/" class="">《C++ STL》</a>
</li>

<li class="header">计算机基础知识</li>

<li>
<a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="">《操作系统》</a>
</li>

<li>
<a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="">《计算机网络》</a>
</li>

<li>
<a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="">《数据结构》</a>
</li>

<li>
<a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" class="">《海量数据处理》</a>
</li>

<li class="header">《基本手写代码》</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.cpp" class="">《插入排序》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.cpp" class="">《单例模式》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E5%A0%86%E6%8E%92%E5%BA%8F.cpp" class="">《堆排序》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95.cpp" class="">《二分查找法》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E9%9D%9E%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.cpp" class="">《非递归二叉树遍历》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.cpp" class="">《归并排序》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.cpp" class="">《快速排序》</a>
</li>

<li>
<a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.cpp" class="">《智能指针的设计与实现》</a>
</li>

<li class="header">项目基础知识</li>

<li>
<a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" class="">《Linux系统编程及基本命令》</a>
</li>

<li>
<a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/MySQL/" class="">《MySQL》</a>
</li>

<li>
<a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Redis/" class="">《Redis》</a>
</li>

<li>
<a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Socket%E7%BC%96%E7%A8%8B/" class="">《Socket编程》</a>
</li>

<li class="header">代码</li>

<li>
<a href="../../../code/work_with_legacy_code/" class="">《Work with legacy code》</a>
</li>

<li>
<a href="../../../code/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/" class="">《代码大全》</a>
</li>

<li>
<a href="../../../code/%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%AA%E6%9D%A5/" class="">《代码的未来》</a>
</li>

<li>
<a href="../../../code/%E5%9F%BA%E6%9C%AC%E5%8A%9F/" class="">《基本功》</a>
</li>

<li>
<a href="../../../code/%E6%95%8F%E6%8D%B7%E6%8A%80%E8%83%BD%E4%BF%AE%E7%82%BC/" class="">《敏捷技能修炼》</a>
</li>

<li>
<a href="../../../code/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/" class="">《程序员应该知道的97件事》</a>
</li>

<li>
<a href="../../../code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/" class="">《编写可读代码的艺术》</a>
</li>

<li>
<a href="../../../code/%E7%BC%96%E7%A8%8B%E5%8C%A0%E8%89%BA/" class="">《编程匠艺》</a>
</li>

<li>
<a href="../../../code/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" class="">《领域驱动设计》</a>
</li>

<li>
<a href="../../../code/codelife_%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81/" class="">《codelife_不止代码》</a>
</li>

<li class="header">调试技术</li>

<li>
<a href="../../../debug/%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/book/" class="">《软件调试修炼之道》</a>
</li>

<li>
<a href="../../../debug/Effective_Debugging/" class="">《Effective Debugging》</a>
</li>

<li class="header">数据库</li>

<li>
<a href="../../../database/getting_started_with_impala/" class="">《Getting started with impala》</a>
</li>

<li>
<a href="../../../database/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" class="">《mysql必知必会》</a>
</li>

<li>
<a href="../../../database/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/" class="">《mysql性能调优与架构实践》</a>
</li>

<li>
<a href="../../../database/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="">《Mysql技术内幕InnoDB存储引擎》</a>
</li>

<li>
<a href="../../../database/redis%E5%AE%9E%E6%88%98/" class="">《Redis实战》</a>
</li>

<li>
<a href="../../../database/redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/book/" class="">《Redis深度历险核心原理和应用实践》</a>
</li>

<li>
<a href="../../../database/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" class="">《redis设计与实现》</a>
</li>

<li>
<a href="../../../database/%E4%B8%83%E5%91%A8%E4%B8%83%E6%95%B0%E6%8D%AE%E5%BA%93/" class="">《七周七数据库》</a>
</li>

<li>
<a href="../../../database/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmysql/" class="">《深入浅出mysql》</a>
</li>

<li>
<a href="../../../database/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%89%E7%89%88/" class="">《高性能mysql第三版》</a>
</li>

<li class="header">前端</li>

<li>
<a href="../../../frontend/CSS_The_Missing_Manual/" class="">《CSS_The_Missing_Manual》</a>
</li>

<li>
<a href="../../../frontend/reactjs_%E5%B0%8F%E4%B9%A6/" class="">《reactjs小书》</a>
</li>

<li>
<a href="../../../frontend/es6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/" class="">《ES6标准入门》</a>
</li>

<li>
<a href="../../../frontend/jquery_pocket_reference/" class="">《jquery_pocket_reference》</a>
</li>

<li>
<a href="../../../frontend/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3bootstrap/" class="">《深入理解bootstrap》</a>
</li>

<li class="header">golang</li>

<li>
<a href="../../1_the_go_programming_lauguage/" class="">《1 The Go Programming Language》</a>
</li>

<li>
<a href="../../2_the_go_programming_lauguage/" class="">《2 The Go Programming Language》</a>
</li>

<li>
<a href="../../3_the_go_programming_lauguage/" class="">《3 The Go Programming Language》</a>
</li>

<li>
<a href="../../build-web-application-with-golang/" class="">《Build Web Application With Golang》</a>
</li>

<li>
<a href="../../go101/book/" class="">《Go101》</a>
</li>

<li>
<a href="../../network-programming-with-go/book/" class="">《Network Programming with go》</a>
</li>

<li>
<a href="../../building-microservices-with-go/book/" class="">《Building Microservices With Go》</a>
</li>

<li>
<a href="../../building_restful_web_services_with_go/book/" class="">《Building Restful Web Services with Go》</a>
</li>

<li>
<a href="../../concurrency-in-go/concurrency_in_go/" class="">《Concurrency In Go》</a>
</li>

<li>
<a href="../../go_in_action%28go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%29/" class="">《Go In Action(Go 实战)》</a>
</li>

<li>
<a href="../../go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3/" class="">《Go学习笔记语言详解》</a>
</li>

<li>
<a href="../../go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" class="">《Go学习笔记源码剖析》</a>
</li>

<li>
<a href="../../go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" class="">《go语言编程》</a>
</li>

<li>
<a href="../../the_way_to_go/book/" class="">《go book》</a>
</li>

<li>
<a href="./" class="active">《advanced-go-programming》</a>
</li>

<li>
<a href="../../go-build-web-applications/module1/go-build-web-applications/go-build-web-applications/" class="">《go-build-web-applications》</a>
</li>

<li class="header">java</li>

<li>
<a href="../../../java/java-basic-introduction/" class="">《java basic introduction》</a>
</li>

<li class="header">网络</li>

<li>
<a href="../../../network/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/" class="">《TCP IP详解卷一》</a>
</li>

<li class="header">python</li>

<li>
<a href="../../../python/fluent_python/" class="">《Fluent Python》</a>
</li>

<li>
<a href="../../../python/Python_Microservices_Development/" class="">《Python Microservices Development》</a>
</li>

<li>
<a href="../../../python/high_performance_python/" class="">《High Performance Python》</a>
</li>

<li>
<a href="../../../python/python_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="">《Python网络编程》</a>
</li>

<li class="header">unix/linux</li>

<li>
<a href="../../../unix_linux/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" class="">《Linux高性能服务器编程》</a>
</li>

<li>
<a href="../../../unix_linux/unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/" class="">《unix编程艺术》</a>
</li>

<li>
<a href="../../../unix_linux/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/" class="">《unix网络编程卷一》</a>
</li>

<li>
<a href="../../../unix_linux/unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/" class="">《unix编程艺术》</a>
</li>

<li>
<a href="#">《APUE》</a>
<ul>

<li>
<a href="../../../unix_linux/APUE/environ/" class="">《APUE environ》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/fork/" class="">《APUE fork》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/gcc/" class="">《APUE gcc》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/IO/" class="">《APUE IO》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/IPC/" class="">《APUE IPC》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/makefile/" class="">《APUE makefile》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/wait/" class="">《APUE wait》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E5%8A%A8%E6%80%81%E5%BA%93%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93/" class="">《APUE 动态库和静态库》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" class="">《APUE 守护进程》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/" class="">《APUE 文件权限》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E7%B3%BB%E7%BB%9FIO%E5%87%BD%E6%95%B0/" class="">《APUE 系统IO函数》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E4%BF%A1%E5%8F%B7/" class="">《APUE 信号》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E4%BF%A1%E5%8F%B72/" class="">《APUE 信号2》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0/" class="">《线程函数》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" class="">《线程基础》</a>
</li>

<li>
<a href="../../../unix_linux/APUE/%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/" class="">《线程同步》</a>
</li>
</ul>
</li>

<li class="header">分布式</li>

<li>
<a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" class="">《Kafka 权威指南》</a>
</li>

<li>
<a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" class="">《分布式框架原理与应用》</a>
</li>

<li>
<a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="">《大规模分布式存储系统》</a>
</li>

<li>
<a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/" class="">《深入分布式缓存从原理到实践》</a>
</li>

<li class="header">搜索引擎</li>

<li>
<a href="../../../%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/Elasticsearch%E5%AE%9E%E6%88%98/book/" class="">《Elasticsearch实战》</a>
</li>

<li class="header">容器</li>

<li>
<a href="../../../devops/%E7%8E%A9%E8%BD%ACKubernets-CloudMan/" class="">《玩转Kubernets》</a>
</li>

<li>
<a href="../../../devops/%E7%AC%AC%E4%B8%80%E6%9C%ACdocker%E4%B9%A6/" class="">《第一本docker书》</a>
</li>

<li class="header">开发工具</li>

<li>
<a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/practical_vim/practical_vim/" class="">《Practical Vim》</a>
</li>

<li>
<a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vim8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/vim8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/" class="">《Vim8文本处理实战》</a>
</li>

<li>
<a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/learn_vim_the_hard_way/" class="">《Learn vim scrpt the hard way》</a>
</li>

<li>
<a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/pro_git/" class="">《Pro Git》</a>
</li>

<li>
<a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Mastering_vim/" class="">《Mastering Vim》</a>
</li>

<li>
<a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/mastering_vim_quickly/" class="">《Mastering Vim Quickly》</a>
</li>

<li class="header">思维</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E4%B8%93%E6%B3%A8%E5%8A%9B_%E5%8C%96%E7%B9%81%E4%B8%BA%E7%AE%80%E7%9A%84%E6%83%8A%E4%BA%BA%E5%8A%9B%E9%87%8F/" class="">《专注力》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E8%BF%99%E6%A0%B7%E7%94%A8%E8%84%91%E4%B8%8D%E4%BC%9A%E7%B4%AF/" class="">《为什么精英这样用脑不会累》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/" class="">《刻意练习》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%A6%82%E4%BD%95%E6%83%B3%E5%88%B0%E5%8F%88%E5%81%9A%E5%88%B0/" class="">《如何想到又做到》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/" class="">《学习之道》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%AD%A6%E4%B9%A0%E5%8A%9B/" class="">《学习力》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7/" class="">《批判性思维工具》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BF%AE%E7%82%BC%28%E5%BC%80%E5%8F%91%E8%AE%A4%E7%9F%A5%E6%BD%9C%E8%83%BD%E7%9A%84%E4%B9%9D%E5%A0%82%E8%AF%BE%29/" class="">《程序员的思维修炼》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E8%AE%A4%E7%9F%A5%E5%A4%A9%E6%80%A7/" class="">《认知天性》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E8%B6%85%E6%95%88%E7%8E%87%E6%89%8B%E5%86%8C/" class="">《超效率手册》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%AE%B0%E5%BF%86/" class="">《如何高效记忆》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E7%A7%91%E5%AD%A6%E5%AD%A6%E4%B9%A0/" class="">《科学学习》</a>
</li>

<li>
<a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF/" class="">《高效程序员的45个习惯》</a>
</li>

<li class="header">源码</li>

<li>
<a href="../../../%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_sourcecode/" class="">《源码阅读》</a>
</li>

<li class="header">网站架构微服务</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/microservices_patterns_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/book/" class="">《微服务架构设计模式》</a>
</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/" class="">《从0开始学架构》</a>
</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/web_scalavility_for_startup_engineers/" class="">《web scalavility for startup engineers》</a>
</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/design_data_instensive_application/" class="">《design_data_instensive_application》</a>
</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/clean_architecture/" class="">《clean_architecture》</a>
</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/" class="">《微服务设计》</a>
</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/2_design_data_instensive_application/" class="">《2_design_data_instensive_application》</a>
</li>

<li>
<a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/3_design_data_instensive_application/" class="">《3_design_data_instensive_application》</a>
</li>

<li class="header">软件工程/项目管理</li>

<li>
<a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" class="">《人月神话》</a>
</li>

<li>
<a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BB%A3%E7%A0%81%E4%B9%8B%E6%AE%87/" class="">《代码之殇》</a>
</li>

<li>
<a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%A7%A3%E6%9E%90%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B-%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/" class="">《解析极限编程》</a>
</li>

<li>
<a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/" class="">《项目管理修炼之道》</a>
</li>

<li>
<a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BF%AE%E6%94%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%89%BA%E6%9C%AF/" class="">《修改软件的艺术》</a>
</li>

<li class="header">运维</li>

<li>
<a href="../../../%E8%BF%90%E7%BB%B4/linux%E9%9B%86%E7%BE%A4%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/" class="">《linux集群和自动化运维》</a>
</li>

<li>
<a href="../../../%E8%BF%90%E7%BB%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/" class="">《python自动化运维》</a>
</li>

<li class="header">金融理财</li>

<li>
<a href="../../../%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/%E5%AE%9A%E6%8A%95%E5%8D%81%E5%B9%B4/" class="">《定投十年》</a>
</li>

<li>
<a href="../../../%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/" class="">《穷查理宝典》</a>
</li>

<li class="header">写作</li>

<li>
<a href="../../../%E5%86%99%E4%BD%9C/%E5%88%B7%E5%B1%8F%E6%96%87%E6%A1%88%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/" class="">《刷屏文案写作技巧》</a>
</li>

<li class="header">互联网</li>

<li>
<a href="../../../%E4%BA%92%E8%81%94%E7%BD%91/%E6%88%91%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%91%A8%E9%B8%BF%E7%A5%8E/" class="">《我的互联网方法论-周鸿祎》</a>
</li>

<li>
<a href="../../../%E4%BA%92%E8%81%94%E7%BD%91/%E7%94%A8%E6%88%B7%E6%80%9D%E7%BB%B4/" class="">《用户思维》</a>
</li>

<li class="header">区块链</li>

<li>
<a href="../../../%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97%28blockchain_guide%29/" class="">《区块链技术指南》</a>
</li>

<li class="header">技术演讲</li>

<li>
<a href="../../../lecture/Gopher/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E7%9A%84go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/note/" class="">《哔哩哔哩的go微服务实战》</a>
</li>

<li>
<a href="../../../lecture/Gopher/Go_Error/go%E4%B8%9A%E5%8A%A1%E5%9F%BA%E7%A1%80%E5%BA%93%E4%B9%8BError%26Context/" class="">《go业务基础库之Error&Context》</a>
</li>

<li>
<a href="../../../lecture/Gopher/Go%E5%90%8C%E6%AD%A5%E5%92%8C%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/note/" class="">《Go同步和并发设计模式》</a>
</li>

<li>
<a href="../../../lecture/%E6%8A%80%E6%9C%AF%E6%BC%94%E8%AE%B2/%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90-%E6%88%91%E8%BF%99%E6%8A%80%E6%9C%AF%E4%BA%8C%E5%8D%81%E5%B9%B4/" class="">《左耳朵耗子-我这技术二十年》</a>
</li>

<li class="header">职场</li>

<li>
<a href="../../../career/give_and_take/" class="">《give and take》</a>
</li>

<li>
<a href="../../../career/the_effective_engineer/" class="">《the_effective_engineer》</a>
</li>

<li>
<a href="../../../career/%E5%85%89%E9%80%9F%E6%88%90%E9%95%BF/" class="">《光速成长》</a>
</li>

<li>
<a href="../../../career/%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86/" class="">《向上管理》</a>
</li>

<li>
<a href="../../../career/%E6%88%90%E5%8A%9F%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E6%A0%87/" class="">《成功动机与目标》</a>
</li>

<li>
<a href="../../../career/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/" class="">《番茄工作法》</a>
</li>

<li>
<a href="../../../career/%E8%81%86%E5%90%AC%E6%B2%9F%E9%80%9A%E5%AD%A6/" class="">《聆听沟通学》</a>
</li>

<li>
<a href="../../../career/%E7%9F%A5%E4%B9%8E%E8%81%8C%E4%BA%BA%E8%A7%89%E9%86%92/" class="">《知乎职人觉醒》</a>
</li>

<li>
<a href="../../../career/%E7%9F%A5%E8%AF%86%E5%8F%98%E7%8E%B0/" class="">《知识变现》</a>
</li>

<li>
<a href="../../../career/%E8%81%86%E5%90%AC%E6%B2%9F%E9%80%9A%E5%AD%A6/" class="">《聆听沟通学》</a>
</li>

<li>
<a href="../../../career/%E8%81%8C%E5%9C%BA%E5%8A%A8%E7%89%A9%E8%BF%9B%E5%8C%96%E6%89%8B%E5%86%8C/" class="">《职场动物进化手册》</a>
</li>

<li>
<a href="../../../career/%E8%81%8C%E5%9C%BA%E8%A7%A3%E9%87%8A%E7%B3%BB/" class="">《职场解释系》</a>
</li>

<li>
<a href="../../../career/%E8%AF%B7%E5%81%9C%E6%AD%A2%E6%97%A0%E6%95%88%E5%8A%AA%E5%8A%9B/" class="">《请停止无效努力》</a>
</li>

<li>
<a href="../../../career/%E8%BD%AF%E6%8A%80%E8%83%BD/" class="">《软技能》</a>
</li>

<li>
<a href="../../../career/%E9%AB%98%E6%95%8815%E6%B3%95%E5%88%99/" class="">《高效15法则》</a>
</li>

<li>
<a href="../../../career/%E9%AB%98%E6%95%88%E6%B8%85%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%B3%95/" class="">《高效清单工作法》</a>
</li>

<li>
<a href="../../../career/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" class="">《程序员的自我修养》</a>
</li>

<li class="header">心理学</li>

<li>
<a href="../../../psychology/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E7%AB%A5%E5%B9%B4%E7%9A%84%E9%94%99%E5%90%97/" class="">《一切都是童年的错吗》</a>
</li>

<li>
<a href="../../../psychology/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/" class="">《亲密关系》</a>
</li>

<li>
<a href="../../../psychology/%E6%83%85%E5%95%86/" class="">《情商》</a>
</li>

<li>
<a href="../../../psychology/%E6%8B%96%E5%BB%B6%E5%BF%83%E7%90%86%E5%AD%A6/" class="">《拖延心理学》</a>
</li>

<li>
<a href="../../../psychology/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/" class="">《积极心理学》</a>
</li>

<li>
<a href="../../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B/" class="">《自控力》</a>
</li>

<li>
<a href="../../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B-%E5%92%8C%E5%8E%8B%E5%8A%9B%E5%81%9A%E6%9C%8B%E5%8F%8B/" class="">《自控力:和压力做朋友》</a>
</li>

<li>
<a href="../../../psychology/%E6%B4%BB%E5%87%BA%E6%9C%80%E4%B9%90%E8%A7%82%E7%9A%84%E8%87%AA%E5%B7%B1/" class="">《活出最乐观的自己》</a>
</li>

<li>
<a href="../../../psychology/%E6%94%B9%E5%8F%98%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%8440%E9%A1%B9%E7%A0%94%E7%A9%B6/" class="">《改变心理学的40项研究》</a>
</li>

<li>
<a href="../../../psychology/%E8%B6%85%E8%B6%8A%E8%87%AA%E5%8D%91/" class="">《超越自卑》</a>
</li>

<li>
<a href="../../../psychology/%E5%8F%8D%E8%84%86%E5%BC%B1/" class="">《反脆弱》</a>
</li>

<li class="header">创业</li>

<li>
<a href="../../../startup/hello_startup/" class="">《Hello Startup》</a>
</li>

<li>
<a href="../../../startup/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%85%AC%E5%BC%80%E8%AF%BE-%E5%A6%82%E4%BD%95%E5%88%9B%E4%B8%9A/" class="">《斯坦福公开课如何创业》</a>
</li>

<li>
<a href="../../../startup/%E8%BF%90%E8%90%A5%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95/" class="">《运营其实很简单》</a>
</li>

<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h3 id="153">1.5.3 顺序一致性内存模型</h3>
<p>go 中同一个 goroutine 保证顺序一致性内存模型，但是不同 goroutine 之间不保证，需要定义明确的同步事件。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    go fmt.Println(&quot;hello&quot;)
}

// 使用 done 同步
func main() {
    done := make(chan int, 1)

    go func() {
        fmt.Println(&quot;hello&quot;)
        done &lt;- 1 // 同一个 goroutine 满足顺序一致性，这个时候已经打印
    }()

    &lt;-done
}

// 或者用mutex同步
func main() {
    var mu sync.Mutex
    mu.Lock()
    go func() {
        fmt.Println(&quot;hello&quot;)
        mu.Unlock() // UhLck一定在 print 之后发生
    }()
    mu.Lock() // Lock一定在unlock之后发生，通过sync.Mutex保证
}
</code></pre>

<h3 id="154">1.5.4 初始化顺序</h3>
<p><img alt="" src="../init_order.png" /></p>
<h3 id="156-channel">1.5.6 基于Channel通信</h3>
<pre><code class="go">// 利用channel缓存大小控制并发执行的goroutine最大数
var limit = make(chan int, 3)

func main() {
    for _, w := range work {
        go func() {
            limit &lt;- 1
            w()
            &lt;-limit
        }()
    }
    select {} // 阻塞 main，避免过早退出
}
</code></pre>

<h2 id="16">1.6 常见并发模式</h2>
<p>CSP: 同步通信</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.
不要通过共享内存来通信，而应通过通信共享内存。</p>
</blockquote>
<h3 id="161-hello-world">1.6.1 并发Hello World</h3>
<p>并发编程核心概念是同步通信。</p>
<pre><code class="go">// 错误的示例
package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func main() {
    var mu sync.Mutex
    mu.Lock()
    go func() {
        fmt.Println(&quot;hello&quot;)
        mu.Lock()
    }()
    mu.Unlock()  //这里的Lock/Unlock无法保证顺序，必须先Lock之后才能Unlock
}
</code></pre>

<p>修复方式用main 中使用两次 lock</p>
<pre><code class="go">func main() {
    var mu sync.Mutex
    mu.Lock()
    go func() {
        fmt.Println(&quot;hello&quot;)
        mu.Unlock() // UhLck一定在 print 之后发生
    }()
    mu.Lock() // Lock一定在unlock之后发生，通过sync.Mutex保证
}
</code></pre>

<p>使用无缓冲管道实现同步:</p>
<pre><code class="go">func main() {
    done := make(chan int)

    go func() {
        fmt.Println(&quot;hello&quot;)
        &lt;- done
    }()
    done &lt;- 1   // 发送操作完成才有可能接受，所以会等待先执行 &lt;-done

}
</code></pre>

<p>对于无缓存Channel 进行的接收，发生在对该 channel 进行发送完成之前。</p>
<p>更好的做法是将管道的发送和接受方调换，使用有缓存的管道。避免同步受到管道缓存大小影响。
对于带缓冲的channel,对于channel 的第 k 个接手完成操作发生在第k+c 个发送操作完成之前，
其中 c 是 channel 的缓存大小。</p>
<pre><code class="go">func main() {
    done := make(chan int, 1)

    go func() {
        fmt.Println(&quot;hello&quot;)
        done &lt;- 1
    }()
    &lt;-done
}
</code></pre>

<p>扩展到 n 个：</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
)

func main() {
    done := make(chan int, 10)

    for i := 0; i &lt; cap(done); i++ {
        go func() {
            fmt.Println(&quot;hello&quot;)
            done &lt;- 1
        }()
    }

    for i := 0; i &lt; cap(done); i++ {
        &lt;-done
    }

}
</code></pre>

<p>当然最简单的方式使用 sync.WaitGroup , wg.Add wg.Done wg.Wait</p>
<h3 id="162">1.6.2 生产者消费者</h3>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;os/signal&quot;
    &quot;syscall&quot;
)

func Producer(factor int, out chan&lt;- int) {
    for i := 0; ; i++ {
        out &lt;- i * factor
    }
}

func Consumer(in &lt;-chan int) {
    for v := range in {
        fmt.Print(v)
    }
}

func main() {
    ch := make(chan int, 64)
    go Producer(3, ch)
    go Producer(5, ch)
    go Consumer(ch)

    sig := make(chan os.Signal, 1)
    signal.Notify(sig, syscall.SIGINT, syscall.SIGTERM)
    fmt.Printf(&quot;quit %v\n&quot;, &lt;-sig)
}
</code></pre>

<h3 id="163">1.6.3 发布订阅</h3>
<p>Pub/Sub m:n</p>
<h3 id="164">1.6.4 控制并发数</h3>
<p>通过带缓存管道的发送和接收规则实现最大并发阻塞。</p>
<pre><code class="go">package main

var limit = make(chan int, 3)

func main() {
    for _, w := range work {
        go func() {
            limit &lt;- 1
            w()
            &lt;-limit
        }()
    }
    select {}
}

type gate chan bool 
func (g gate) enter() { g&lt;-true }
func (g gate) leave() { &lt;-g }

type gatefs struct {
    fs vfs.FileSystem
    gate
}

func (fs gatefs) Lstat(p string) (os.FileInfo, error) {
    fs.enter()
    defer fs.leave()
    return fs.fs.Lstat(p)
}
</code></pre>

<h3 id="165">1.6.5 赢者为王</h3>
<pre><code class="go">func main() {
    ch := make(chan string, 32)

    go func() {
        ch &lt;- searchByBing(&quot;golang')&quot;
    }()

    go func() {
        ch &lt;- searchByGoogle(&quot;golang')&quot;
    }()

    go func() {
        ch &lt;- searchByBaidu(&quot;golang')&quot;
    }()

    fmt.Println(&lt;-ch)
}
</code></pre>

<h3 id="167">1.6.7 并发安全退出</h3>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func worker(wg *sync.WaitGroup, cannel chan bool) {
    defer wg.Done()

    for {
        select {
        default:
            fmt.Println(&quot;hello&quot;)
        case &lt;-cannel:
            return
        }
    }
}

func main() {
    cancel := make(chan bool)

    var wg sync.WaitGroup
    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go worker(&amp;wg, cancel)
    }
    time.Sleep(time.Second)
    close(cancel)
    wg.Wait()
}
</code></pre>

<h3 id="168-context">1.6.8 context 包</h3>
<p>go1.7 增加了 context, 简化对于处理单个请求的多个goroutine之间与请求域的数据、超时和退出等操作。</p>
<h1 id="17">1.7 错误和异常</h1>
<p>错误被认为可预期的，异常则是非预期的。</p>
<h3 id="171">1.7.1 错误处理策略</h3>
<p>go 中的导出函数一般不抛出异常，一个未受控的异常可以看成程序 bug。
web框架一般会防御性地捕获所有异常。</p>
<pre><code class="go">// go库实现习惯是即使包内部使用了 panic，但是在函数 export 时候会被转换成明确的错误值
func ParseJSON(input string) (s *Syntax, err error) {
    defer func() {
        if p:=recover(); p!=nil {
            err = fmt.Errorf(&quot;JSON: internal error: %v&quot;, p)
        }
    }()
    // ... parser ...
}
</code></pre>

<h3 id="172">1.7.2 获取错误上下文</h3>
<p>一般为了防止丢失错误信息，一般使用包装函数。
go 大部分代码逻辑类似，先一系列初始检查，用于防止错误发生，然后是实际逻辑。</p>
<pre><code class="go">f, err := op.Open(&quot;filename&quot;)
if err !=nil {
    // 失败场景
}
// 正常流程
</code></pre>

<p>`1.7.3 错误的错误返回</p>
<p>go 中 error 是一种接口类型。接口信息包含了原始类型和原始的值。
只有当接口的类型和原始值都为空，接口值才对应 nil。`</p>
<pre><code class="go">// 错误示例
func returnsError() error {
    var p *MyError = nil
    if bad() {
         p = ErrBad
    }
    return p // weill always return a non-nil error
    // 返回的是一个Myerror类型的空指针，而不是 nil
}

// rightway
func returnsError() error {
    if bad() {
        return (*MyError)(err)
    }
    return nil
}

</code></pre>

<h3 id="174">1.7.4 剖析异常</h3>
<p>必须在 defer 函数中直接调用 recover，并且不能包装 recover 函数，直接调用。
必须和有异常的栈帧只隔一个栈帧才能正确捕获异常。</p>
<p>--- 2章 CGO 编程</p>
<p>--- 4章 RPC和Protobuf</p>
<p>RPC (Remote Procedure Call)</p>
<h2 id="41-rpc">4.1 RPC 入门</h2>
<p>示例使用了内置的rpc 模块演示</p>
<h2 id="42-protobuf">4.2 Protobuf</h2>
<p>Prtocol Buffers简称</p>
<h2 id="43-rpc">4.3 玩转 RPC</h2>
<h2 id="44-grpc">4.4 gRPC 入门</h2>
<p>基于 HTTP/2 协议设计，可以基于一个HTTP/2链接提供多个服务。</p>
<p><img alt="" src="../grpc.png" /></p>
<h1 id="5-go-web">5 Go和 web</h1>
<p>go web框架使用radix tree 实现 route</p>
<h2 id="53-middleware">5.3 中间件middleware</h2>
<p>解耦业务和非业务代码逻辑</p>
<pre><code class="go">package main

import (
    &quot;net/http&quot;
    &quot;time&quot;
)

func hello(wr http.ResponseWriter, r *http.Request) {
    wr.Write([]byte(&quot;hello&quot;))
}

func timeMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(wr http.ResponseWriter, r *http.Request) {
        timeStart := time.Now()
        // next handler
        next.ServeHTTP(wr, r)

        timeElasped := time.Since(timeStart)
        logger.Println(timeElasped)
    })
}

func main() {
    http.Handle(&quot;/&quot;, timeMiddleware(http.HandlerFunc(hello)))
    err := http.ListenAndServe(&quot;:8000&quot;, nil)
    //....
}


// 标准库的关系
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}

type HandlerFunc func(ResponseWriter, *Request) 

func (f handlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
</code></pre>

<p>请求调用链：</p>
<p>h = getHandler() =&gt; h.ServeHTTP(w, r) =&gt; h(w, r)</p>
<h3 id="533">5.3.3 更优雅的中间件写法</h3>
<pre><code class="go">r = NewRouter()
r.Use(logger)
r.Use(timeout)
r.Use(ratelimit)
r.Add(&quot;/&quot;, helloHandler)

type middleware func(http.Handler) http.Handler 
type Router struct {
    middlewareChain [] middleware
    mux map[string] http.Handler
}

func NewRouter() *Router{ 
    return &amp;Router{}
}

func (r *Router) Use(m middleware) {
    r.middlewareChain = append(r.middlewareChain, m)
}

func (r *Router) Add(route string, h http.Handler) {
    var mergedHandler = h
    // 反向遍历
    for i:= len(r.middlewareChain)-1; i&gt;=0; i-- {
        mergedHandler = r.middlewareChain[i](mergedHandler)
    }
    r.mux[route] = mergedHandler
}
</code></pre>

<p>哪些可以写成中间件呢？参考 gin-gonic/contrib</p>
<h2 id="54-validator">5.4 Validator</h2>
<p>https://github.com/go-playground/validator</p>
<p>通过反射对结构体进行树形遍历</p>
<h2 id="55-database">5.5 Database 和数据库打交道</h2>
<pre><code class="go">package main
import &quot;database/sql&quot;
import _ &quot;github.com/go-sql-driver/mysql&quot; 

db, err := sql.Open(&quot;mysql&quot;, &quot;user:password@/dbname&quot;)

// import _ &quot;github.com/go-sql-driver/mysql&quot;  实际上调用了 mysql init
func init() {
    sql.Register(&quot;mysql&quot;, &amp;MySQLDriver{})
}
</code></pre>

<p>Sql Build 相比orm 在可维护性上取得了更好平衡，不会屏蔽太多细节。</p>
<h3 id="56-ratelimit">5.6 Ratelimit 服务流量限制</h3>
<p>磁盘 IO/CPU/带宽瓶颈</p>
<p>常见的限流手段：</p>
<ul>
<li>漏桶: 有一个一直装满水的桶，每过固定一段时间向外漏一滴水。如果你接收到了这滴水，就可以继续请求服务，否则等待下一滴水</li>
</ul>
<ul>
<li>令牌桶: 匀速向桶中添加令牌，服务请求需要从桶中获取令牌</li>
</ul>
<p>令牌桶使用比较广泛，业界流行限流器大多数基于令牌桶。</p>
<p>github.com/juju/ratelimit</p>
<p>原理：令牌桶模型实际上是对全局计数的加减法操作过程，
但使用计数器需要自己加上读写锁。</p>
<p>可以使用 bufferd channel 完成简单的加令牌和取令牌操作。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    var fillInterval = time.Millisecond * 10
    var capacity = 100
    var tokenBucket = make(chan struct{}, capacity)

    fillToken := func() {
        ticker := time.NewTicker(fillInterval)
        for {
            select {
            case &lt;-ticker.C:
                select {
                case tokenBucket &lt;- struct{}{}:
                default:

                }
                fmt.Println(&quot;current token cnt:&quot;, len(tokenBucket), time.Now())
            }
        }
    }

    go fillToken()
    time.Sleep(time.Hour)
}

func TakeAvailable(block bool) bool {
    var takenResult bool
    if block {
        select {
        case &lt;-tokenBucket:
            takenResult = true
        }
    } else {
        select {
        case &lt;-tokenBucket:
            takenResult = true
        default:
            takenResult = false
        }
    }
    return takenResult
}
</code></pre>

<h3 id="563-qos">5.6.3服务瓶颈和 Qos</h3>
<p>Qos: Quality of Service。包含可用性、吞吐量、时延、时延变化和丢失等</p>
<h2 id="57">5.7 大型项目分层</h2>
<ul>
<li>controller: 服务入口，负责处理路由，参数校验，请求转发</li>
<li>logic/service: 逻辑(服务)层，一般是业务逻辑入口。可以认为从这里开始参数一定是合法的。业务逻辑和流程也在这一层。(Business Rules)</li>
<li>DAO/Repository: 负责和数据、存储打交道。更简单的函数、接口暴露给Logic层使用。负责数据持久化。</li>
</ul>
<h2 id="58">5.8 接口和表驱动开发</h2>
<h3 id="582">5.8.2 使用函数封装业务流程</h3>
<p>把相似的行为放在一起，然后打包成一个个函数。</p>
<h3 id="583">5.8.3 使用接口来做抽象</h3>
<p>业务早期不建议引入接口。主流程稳定可以引入接口做抽象</p>
<h3 id="584">5.8.4 接口优缺点</h3>
<p>优点:正交性。依赖反转
缺点：难以查找实现了接口的类型</p>
<h3 id="585">5.8.5 表驱动开发</h3>
<pre><code class="go">func entry() {
    var bi BusinessInstance
    switch businessType {
    case TravelBusiness:
        bi = travelorder.New()
    case MarketBusiness:
        bi = marketorder.New()
    default:
        return errors.New(&quot;not supported business&quot;)
    }
}

var BusinessInstanceMap = map[int]BusinessInstance{
    TravelBusiness: travelorder.New(),
    MarketBusiness: marketorder.New(),
}

func entry() {
    bi := BusinessInstance[businessType]
}
</code></pre>

<h2 id="59-ab-test">5.9 灰度发布和A/B test</h2>
<p>恢复一般两种方式实现：</p>
<ul>
<li>分批次部署实现灰度发布。1-2-4-8-32... 个机器。通过观察日志和监控系统发现错误</li>
<li>通过业务规则进行灰度发布。比如针对用户 id 取模，落在一定范围内的执行相关逻辑</li>
</ul>
<p>如果使用哈希算法，需要注意性能和均匀度。</p>
<h1 id="6">6 分布式系统</h1>
<h2 id="61-id">6.1 分布式 id 生成器</h2>
<p>twitter snowflake 算法</p>
<p><img alt="" src="../snowflake.png" /></p>
<p>github.com/bwmarrin/snowflake 轻量级的snowflake实现。</p>
<p>sonyflake sony一个开源项目，思路和snowflake类似，分配上有所不同</p>
<p>github.com/sony/sonyflake</p>
<h2 id="62">6.2 分布式锁</h2>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;os&quot;

    &quot;github.com/bwmarrin/snowflake&quot;
)

func main() {
    n, err := snowflake.NewNode(1)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }

    for i := 0; i &lt; 3; i++ {
        id := n.Generate()
        fmt.Println(&quot;id&quot;, id)
        fmt.Println(
            &quot;node: &quot;, id.Node(),
            &quot;step: &quot;, id.Step(),
            &quot;time: &quot;, id.Time(),
            &quot;\n&quot;,
        )
    }
}
</code></pre>

<h3 id="621">6.2.1 进程内加锁</h3>
<p>trylock: 尝试加锁，加锁成功执行后续流程，如果加锁失败也不会阻塞，
而会直接返回加锁结果。go 中可以用大小为1的 channel 模拟 trylock。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

type Lock struct {
    c chan struct{}
}

func NewLock() Lock {
    var l Lock
    l.c = make(chan struct{}, 1)
    l.c &lt;- struct{}{}
    return l
}

func (l Lock) Lock() bool {
    lockResult := false
    select {
    case &lt;-l.c:
        lockResult = true
    default:
    }
    return lockResult
}

func (l Lock) UnLock() {
    l.c &lt;- struct{}{}
}

var counter int

func main() {
    var l = NewLock()
    var wg sync.WaitGroup
    for i := 0; i &lt; 10; i++ {
        wg.Add(1) // add 1
        go func() {
            defer wg.Done()
            if !l.Lock() {
                fmt.Println(&quot;lock failed&quot;)
                return
            }
            counter++
            fmt.Println(&quot;current counter&quot;, counter)
            l.UnLock()
        }()
    }
    wg.Wait()
}
</code></pre>

<p>单机系统 trylock 不好，大量 goroutine 抢锁可能导致 cpu 无意义浪费。(活锁)</p>
<h3 id="623-redis-setnx">6.2.3 基于 redis setnx</h3>
<p>redis setnx 模拟分布式锁</p>
<p>适合高并发场景下，用来争抢一些唯一的资源。
不过依赖请求达到 redis 的顺序，网络慢的用户就自求多福了</p>
<h3 id="624-zookeeper">6.2.4 基于 ZooKeeper</h3>
<p>github.com/samuel/go-zookeeper/zk</p>
<p>基于 ZooKeeper 的锁与基于redis的锁不同之处在于 Lock 成功之前会一直阻塞，
与单机中的 mutex.Lock 很相似。</p>
<p>分布式阻塞锁 适合分布式任务调度场景，但是不适合高频次持有锁时间短的抢锁场景。</p>
<p>Google(chubby论文)，基于强一致性的锁适用于粗粒度加锁操作，粗粒度指的是占用时间较长。</p>
<pre><code class="go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;

    &quot;github.com/samuel/go-zookeeper/zk&quot;
)

func main() {
    c, _, err := zk.Connect([]string{&quot;127.0.0.1&quot;}, time.Second)
    if err != nil {
        panic(err)
    }
    l := zk.NewLock(c, &quot;/lock&quot;, zk.WorldACL(zk.PermAll))
    err = l.Lock()
    if err != nil {
        panic(err)
    }
    fmt.Println(&quot;lock success, do your logic&quot;)
    time.Sleep(time.Second * 10)

    l.UnLock()
    fmt.Println(&quot;unlock success, finish your logic&quot;)
}
</code></pre>

<h3 id="625-etcd">6.2.5 基于 etcd</h3>
<p>类似 ZooKeeper 的组件</p>
<p>github.com/zieckey/etcdsync</p>
<p>根据性能和可靠性、运维成本等仔细权衡使用哪一种分布式锁方案。</p>
<h2 id="63">6.3 延时任务系统</h2>
<ul>
<li>实现一套类似 crontab 的分布式定时任务管理</li>
<li>实现一个支持定时发送消息的消息队列</li>
</ul>
<h3 id="631">6.3.1 定时器实现</h3>
<h4 id="6311">6.3.1.1 时间堆</h4>
<p>小顶堆, golang 内置定时器实现</p>
<h4 id="6312">6.3.1.2 时间轮</h4>
<p>任务分发：</p>
<ul>
<li>监听消息。保证消息队列高可用</li>
<li>调用回调函数。放置函数拖垮系统</li>
</ul>
<h3 id="633">6.3.3 数据再平衡和幂等</h3>
<p>参考 ElasticSearch 的数据分布设计，每份任务数据有多个副本。</p>
<p>很多队列不支持 exactly once 语义，这种情况下需要用户自己负责消息去重或者消费的幂等处理。</p>
<h2 id="64">6.4 分布式搜索引擎</h2>
<p>关系型数据库通常用于OLTP(online transaction processing)</p>
<p>ElasticSearch 是开源分布式搜索引擎霸主</p>
<p>倒排索引</p>
<p>查询 DSL：es 定义了一套查询 DSL。bool query</p>
<p>基于 client sdk 开发：</p>
<p>"gopkg.in/olivere/elastic.v3"</p>
<p>不要把 es 当成强一致性数据库用</p>
<ul>
<li>异构数据同步</li>
</ul>
<p>更常见的场景是同步数据到搜所引擎</p>
<ul>
<li>基于时间戳</li>
<li>通过 binlog。阿里开源的 Canal</li>
</ul>
<h2 id="65">6.5 负载均衡</h2>
<ul>
<li>按顺序处理</li>
<li>随机挑选</li>
<li>根据某种权重</li>
</ul>
<p>洗牌算法，shuffle。注意 rand.Seec(time.Now().UnixNano()) 设置种子</p>
<h3 id="653-zookeeper">6.5.3 ZooKeeper 集群的随机节点挑选问题</h3>
<h2 id="66">6.6 分布式配置管理</h2>
<h3 id="662-etcd">6.6.2 使用 etcd 实现配置更新</h3>
<p>简单的配置可以讲内容完全存储在 etcd 中。</p>
<pre><code class="sh">etcdctl get /configs/remote_config.json
</code></pre>

<h3 id="663">6.6.3 配置膨胀</h3>
<p>支持版本管理进行回滚</p>
<p>客户端缓存容错</p>
<h2 id="67">6.7 分布式爬虫</h2>
<h2 id="671-colly">6.7.1 基于 colly 单机爬虫</h2>
<h2 id="672">6.7.2 分布式爬虫</h2>
<p>nats go 高性能分布式消息队列</p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../../../js/main.js"></script>
<script src="../../../search/main.js"></script>
<script src="../../../js/gitbook.min.js"></script>
<script src="../../../js/theme.min.js"></script>
</body>
</html>