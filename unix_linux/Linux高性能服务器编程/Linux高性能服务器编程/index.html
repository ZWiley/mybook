


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.2">
    
    
      
        <title>Linux高性能服务器编程 - ZWiley的随记</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.a2408e81.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=:300,400,400i,700%7CUbuntu+Mono&display=fallback">
        <style>body,input{font-family:"",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Ubuntu Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#1-tcpip" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../../.." title="ZWiley的随记" class="md-header-nav__button md-logo" aria-label="ZWiley的随记">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            ZWiley的随记
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Linux高性能服务器编程
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://github.com/zwiley/mybook/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="ZWiley的随记" class="md-nav__button md-logo" aria-label="ZWiley的随记">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    ZWiley的随记
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/zwiley/mybook/" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../../.." title="简介" class="md-nav__link">
      简介
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      C++
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="C++" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        C++
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/STL/" title="C++ STL" class="md-nav__link">
      C++ STL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E7%BC%96%E8%AF%91%E5%BA%95%E5%B1%82/" title="C++编译底层" class="md-nav__link">
      C++编译底层
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="C++基础知识" class="md-nav__link">
      C++基础知识
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6_%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2_RTTI/" title="C++智能指针" class="md-nav__link">
      C++智能指针
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="C++面向对象" class="md-nav__link">
      C++面向对象
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      计算机基础
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="计算机基础" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        计算机基础
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统" class="md-nav__link">
      操作系统
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络" class="md-nav__link">
      计算机网络
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构" class="md-nav__link">
      数据结构
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" title="海量数据处理" class="md-nav__link">
      海量数据处理
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      基本手写代码
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="基本手写代码" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        基本手写代码
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/%E5%9F%BA%E6%9C%AC%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%E9%A2%98%E7%9B%AE/" title="常见基本代码" class="md-nav__link">
      常见基本代码
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      项目基础知识
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="项目基础知识" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        项目基础知识
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" title="Linux系统编程及基本命令" class="md-nav__link">
      Linux系统编程及基本命令
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/MySQL/" title="MySQL" class="md-nav__link">
      MySQL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Redis/" title="Redis" class="md-nav__link">
      Redis
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Socket%E7%BC%96%E7%A8%8B/" title="Socket编程" class="md-nav__link">
      Socket编程
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      webserver项目
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="webserver项目" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        webserver项目
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/0%20%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0/" title="0 项目概述" class="md-nav__link">
      0 项目概述
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/1%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%B0%81%E8%A3%85%E7%B1%BB/" title="1 线程同步机制封装类" class="md-nav__link">
      1 线程同步机制封装类
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/2%20%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%8A%EF%BC%89/" title="2 半同步半反应堆线程池（上）" class="md-nav__link">
      2 半同步半反应堆线程池（上）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/3%20%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E4%B8%8B%EF%BC%89/" title="3 半同步半反应堆线程池（下）" class="md-nav__link">
      3 半同步半反应堆线程池（下）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/4%20http%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8A%EF%BC%89/" title="4 http连接处理（上）" class="md-nav__link">
      4 http连接处理（上）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/5%20http%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%AD%EF%BC%89/" title="5 http连接处理（中）" class="md-nav__link">
      5 http连接处理（中）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/6%20http%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/" title="6 http连接处理（下）" class="md-nav__link">
      6 http连接处理（下）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/7%20%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%B8%8A%EF%BC%89/" title="7 定时器处理非活动连接（上）" class="md-nav__link">
      7 定时器处理非活动连接（上）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/8%20%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%B8%8B%EF%BC%89/" title="8 定时器处理非活动连接（下）" class="md-nav__link">
      8 定时器处理非活动连接（下）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/9%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="9 日志系统（上）" class="md-nav__link">
      9 日志系统（上）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/10%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%88%E4%B8%8B%EF%BC%89/" title="10 日志系统（下）" class="md-nav__link">
      10 日志系统（下）
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/11%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" title="11 数据库连接池" class="md-nav__link">
      11 数据库连接池
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../webserver/12%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="12 常见问题" class="md-nav__link">
      12 常见问题
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      数据库
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="数据库" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        数据库
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/getting_started_with_impala/" title="Getting started with impala" class="md-nav__link">
      Getting started with impala
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" title="mysql必知必会" class="md-nav__link">
      mysql必知必会
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/" title="mysql性能调优与架构实践" class="md-nav__link">
      mysql性能调优与架构实践
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" title="Mysql技术内幕InnoDB存储引擎" class="md-nav__link">
      Mysql技术内幕InnoDB存储引擎
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/redis%E5%AE%9E%E6%88%98/" title="Redis实战" class="md-nav__link">
      Redis实战
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/book/" title="Redis深度历险核心原理和应用实践" class="md-nav__link">
      Redis深度历险核心原理和应用实践
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" title="redis设计与实现" class="md-nav__link">
      redis设计与实现
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/%E4%B8%83%E5%91%A8%E4%B8%83%E6%95%B0%E6%8D%AE%E5%BA%93/" title="七周七数据库" class="md-nav__link">
      七周七数据库
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmysql/" title="深入浅出mysql" class="md-nav__link">
      深入浅出mysql
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../database/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%89%E7%89%88/" title="高性能mysql第三版" class="md-nav__link">
      高性能mysql第三版
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-8" type="checkbox" id="nav-8">
    
    <label class="md-nav__link" for="nav-8">
      代码
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="代码" data-md-level="1">
      <label class="md-nav__title" for="nav-8">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        代码
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/" title="代码大全" class="md-nav__link">
      代码大全
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%AA%E6%9D%A5/" title="代码的未来" class="md-nav__link">
      代码的未来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E5%9F%BA%E6%9C%AC%E5%8A%9F/" title="基本功" class="md-nav__link">
      基本功
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E6%95%8F%E6%8D%B7%E6%8A%80%E8%83%BD%E4%BF%AE%E7%82%BC/" title="敏捷技能修炼" class="md-nav__link">
      敏捷技能修炼
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/" title="程序员应该知道的97件事" class="md-nav__link">
      程序员应该知道的97件事
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/" title="编写可读代码的艺术" class="md-nav__link">
      编写可读代码的艺术
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E7%BC%96%E7%A8%8B%E5%8C%A0%E8%89%BA/" title="编程匠艺" class="md-nav__link">
      编程匠艺
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" title="领域驱动设计" class="md-nav__link">
      领域驱动设计
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../code/codelife_%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81/" title="codelife_不止代码" class="md-nav__link">
      codelife_不止代码
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-9" type="checkbox" id="nav-9">
    
    <label class="md-nav__link" for="nav-9">
      调试技术
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="调试技术" data-md-level="1">
      <label class="md-nav__title" for="nav-9">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        调试技术
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../debug/%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/book/" title="软件调试修炼之道" class="md-nav__link">
      软件调试修炼之道
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../debug/Effective_Debugging/" title="Effective Debugging" class="md-nav__link">
      Effective Debugging
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-10" type="checkbox" id="nav-10">
    
    <label class="md-nav__link" for="nav-10">
      前端
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="前端" data-md-level="1">
      <label class="md-nav__title" for="nav-10">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        前端
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../frontend/CSS_The_Missing_Manual/" title="CSS_The_Missing_Manual" class="md-nav__link">
      CSS_The_Missing_Manual
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../frontend/reactjs_%E5%B0%8F%E4%B9%A6/" title="reactjs小书" class="md-nav__link">
      reactjs小书
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../frontend/es6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/" title="ES6标准入门" class="md-nav__link">
      ES6标准入门
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../frontend/jquery_pocket_reference/" title="jquery_pocket_reference" class="md-nav__link">
      jquery_pocket_reference
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../frontend/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3bootstrap/" title="深入理解bootstrap" class="md-nav__link">
      深入理解bootstrap
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-11" type="checkbox" id="nav-11">
    
    <label class="md-nav__link" for="nav-11">
      golang
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="golang" data-md-level="1">
      <label class="md-nav__title" for="nav-11">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        golang
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/1_the_go_programming_lauguage/" title="1 The Go Programming Language" class="md-nav__link">
      1 The Go Programming Language
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/2_the_go_programming_lauguage/" title="2 The Go Programming Language" class="md-nav__link">
      2 The Go Programming Language
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/3_the_go_programming_lauguage/" title="3 The Go Programming Language" class="md-nav__link">
      3 The Go Programming Language
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/build-web-application-with-golang/" title="Build Web Application With Golang" class="md-nav__link">
      Build Web Application With Golang
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/go101/book/" title="Go101" class="md-nav__link">
      Go101
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/network-programming-with-go/book/" title="Network Programming with go" class="md-nav__link">
      Network Programming with go
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/building-microservices-with-go/book/" title="Building Microservices With Go" class="md-nav__link">
      Building Microservices With Go
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/building_restful_web_services_with_go/book/" title="Building Restful Web Services with Go" class="md-nav__link">
      Building Restful Web Services with Go
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/concurrency-in-go/concurrency_in_go/" title="Concurrency In Go" class="md-nav__link">
      Concurrency In Go
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/go_in_action%28go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%29/" title="Go In Action(Go 实战)" class="md-nav__link">
      Go In Action(Go 实战)
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3/" title="Go学习笔记语言详解" class="md-nav__link">
      Go学习笔记语言详解
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="Go学习笔记源码剖析" class="md-nav__link">
      Go学习笔记源码剖析
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/" title="go语言编程" class="md-nav__link">
      go语言编程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/the_way_to_go/book/" title="go book" class="md-nav__link">
      go book
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/advanced-go-programming-book/advanced-go-programming/" title="advanced-go-programming" class="md-nav__link">
      advanced-go-programming
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../golang/go-build-web-applications/module1/go-build-web-applications/go-build-web-applications/" title="go-build-web-applications" class="md-nav__link">
      go-build-web-applications
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-12" type="checkbox" id="nav-12">
    
    <label class="md-nav__link" for="nav-12">
      python
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="python" data-md-level="1">
      <label class="md-nav__title" for="nav-12">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        python
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../python/fluent_python/" title="Fluent Python" class="md-nav__link">
      Fluent Python
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../python/Python_Microservices_Development/" title="Python Microservices Development" class="md-nav__link">
      Python Microservices Development
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../python/high_performance_python/" title="High Performance Python" class="md-nav__link">
      High Performance Python
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../python/python_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="Python网络编程" class="md-nav__link">
      Python网络编程
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-13" type="checkbox" id="nav-13">
    
    <label class="md-nav__link" for="nav-13">
      java
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="java" data-md-level="1">
      <label class="md-nav__title" for="nav-13">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        java
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../java/java-basic-introduction/" title="java basic introduction" class="md-nav__link">
      java basic introduction
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-14" type="checkbox" id="nav-14">
    
    <label class="md-nav__link" for="nav-14">
      网络
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="网络" data-md-level="1">
      <label class="md-nav__title" for="nav-14">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        网络
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../network/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/" title="TCP IP详解卷一" class="md-nav__link">
      TCP IP详解卷一
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-15" type="checkbox" id="nav-15" checked>
    
    <label class="md-nav__link" for="nav-15">
      unix/linux
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="unix/linux" data-md-level="1">
      <label class="md-nav__title" for="nav-15">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        unix/linux
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Linux高性能服务器编程" class="md-nav__link md-nav__link--active">
      Linux高性能服务器编程
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/" title="unix编程艺术" class="md-nav__link">
      unix编程艺术
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/" title="unix网络编程卷一" class="md-nav__link">
      unix网络编程卷一
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/" title="unix编程艺术" class="md-nav__link">
      unix编程艺术
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../unp/unp%E7%AC%94%E8%AE%B0/" title="UNP" class="md-nav__link">
      UNP
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-16" type="checkbox" id="nav-16">
    
    <label class="md-nav__link" for="nav-16">
      分布式
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="分布式" data-md-level="1">
      <label class="md-nav__title" for="nav-16">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        分布式
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/" title="Kafka 权威指南" class="md-nav__link">
      Kafka 权威指南
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" title="分布式框架原理与应用" class="md-nav__link">
      分布式框架原理与应用
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" title="大规模分布式存储系统" class="md-nav__link">
      大规模分布式存储系统
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/" title="深入分布式缓存从原理到实践" class="md-nav__link">
      深入分布式缓存从原理到实践
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-17" type="checkbox" id="nav-17">
    
    <label class="md-nav__link" for="nav-17">
      搜索引擎
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="搜索引擎" data-md-level="1">
      <label class="md-nav__title" for="nav-17">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        搜索引擎
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/Elasticsearch%E5%AE%9E%E6%88%98/book/" title="Elasticsearch实战" class="md-nav__link">
      Elasticsearch实战
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-18" type="checkbox" id="nav-18">
    
    <label class="md-nav__link" for="nav-18">
      容器
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="容器" data-md-level="1">
      <label class="md-nav__title" for="nav-18">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        容器
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../devops/%E7%8E%A9%E8%BD%ACKubernets-CloudMan/" title="玩转Kubernets" class="md-nav__link">
      玩转Kubernets
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../devops/%E7%AC%AC%E4%B8%80%E6%9C%ACdocker%E4%B9%A6/" title="第一本docker书" class="md-nav__link">
      第一本docker书
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-19" type="checkbox" id="nav-19">
    
    <label class="md-nav__link" for="nav-19">
      开发工具
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="开发工具" data-md-level="1">
      <label class="md-nav__title" for="nav-19">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        开发工具
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/practical_vim/practical_vim/" title="Practical Vim" class="md-nav__link">
      Practical Vim
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vim8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/vim8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/" title="Vim8文本处理实战" class="md-nav__link">
      Vim8文本处理实战
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/learn_vim_the_hard_way/" title="Learn vim scrpt the hard way" class="md-nav__link">
      Learn vim scrpt the hard way
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/pro_git/" title="Pro Git" class="md-nav__link">
      Pro Git
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Mastering_vim/" title="Mastering Vim" class="md-nav__link">
      Mastering Vim
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/mastering_vim_quickly/" title="Mastering Vim Quickly" class="md-nav__link">
      Mastering Vim Quickly
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-20" type="checkbox" id="nav-20">
    
    <label class="md-nav__link" for="nav-20">
      源码
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="源码" data-md-level="1">
      <label class="md-nav__title" for="nav-20">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        源码
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_sourcecode/" title="源码阅读" class="md-nav__link">
      源码阅读
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-21" type="checkbox" id="nav-21">
    
    <label class="md-nav__link" for="nav-21">
      网站架构微服务
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="网站架构微服务" data-md-level="1">
      <label class="md-nav__title" for="nav-21">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        网站架构微服务
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/microservices_patterns_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/book/" title="微服务架构设计模式" class="md-nav__link">
      微服务架构设计模式
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/" title="从0开始学架构" class="md-nav__link">
      从0开始学架构
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/web_scalavility_for_startup_engineers/" title="web scalavility for startup engineers" class="md-nav__link">
      web scalavility for startup engineers
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/design_data_instensive_application/" title="design_data_instensive_application" class="md-nav__link">
      design_data_instensive_application
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/clean_architecture/" title="clean_architecture" class="md-nav__link">
      clean_architecture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/" title="微服务设计" class="md-nav__link">
      微服务设计
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/2_design_data_instensive_application/" title="2_design_data_instensive_application" class="md-nav__link">
      2_design_data_instensive_application
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/3_design_data_instensive_application/" title="3_design_data_instensive_application" class="md-nav__link">
      3_design_data_instensive_application
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-22" type="checkbox" id="nav-22">
    
    <label class="md-nav__link" for="nav-22">
      软件工程/项目管理
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="软件工程/项目管理" data-md-level="1">
      <label class="md-nav__title" for="nav-22">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        软件工程/项目管理
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/" title="人月神话" class="md-nav__link">
      人月神话
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BB%A3%E7%A0%81%E4%B9%8B%E6%AE%87/" title="代码之殇" class="md-nav__link">
      代码之殇
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%A7%A3%E6%9E%90%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B-%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/" title="解析极限编程" class="md-nav__link">
      解析极限编程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/" title="项目管理修炼之道" class="md-nav__link">
      项目管理修炼之道
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BF%AE%E6%94%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%89%BA%E6%9C%AF/" title="修改软件的艺术" class="md-nav__link">
      修改软件的艺术
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-23" type="checkbox" id="nav-23">
    
    <label class="md-nav__link" for="nav-23">
      运维
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="运维" data-md-level="1">
      <label class="md-nav__title" for="nav-23">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        运维
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%BF%90%E7%BB%B4/linux%E9%9B%86%E7%BE%A4%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/" title="linux集群和自动化运维" class="md-nav__link">
      linux集群和自动化运维
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E8%BF%90%E7%BB%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/" title="python自动化运维" class="md-nav__link">
      python自动化运维
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-24" type="checkbox" id="nav-24">
    
    <label class="md-nav__link" for="nav-24">
      互联网
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="互联网" data-md-level="1">
      <label class="md-nav__title" for="nav-24">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        互联网
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E4%BA%92%E8%81%94%E7%BD%91/%E6%88%91%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%91%A8%E9%B8%BF%E7%A5%8E/" title="我的互联网方法论-周鸿祎" class="md-nav__link">
      我的互联网方法论-周鸿祎
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E4%BA%92%E8%81%94%E7%BD%91/%E7%94%A8%E6%88%B7%E6%80%9D%E7%BB%B4/" title="用户思维" class="md-nav__link">
      用户思维
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-25" type="checkbox" id="nav-25">
    
    <label class="md-nav__link" for="nav-25">
      区块链
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="区块链" data-md-level="1">
      <label class="md-nav__title" for="nav-25">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        区块链
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97%28blockchain_guide%29/" title="区块链技术指南" class="md-nav__link">
      区块链技术指南
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-26" type="checkbox" id="nav-26">
    
    <label class="md-nav__link" for="nav-26">
      技术演讲
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="技术演讲" data-md-level="1">
      <label class="md-nav__title" for="nav-26">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        技术演讲
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../lecture/Gopher/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E7%9A%84go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/note/" title="哔哩哔哩的go微服务实战" class="md-nav__link">
      哔哩哔哩的go微服务实战
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../lecture/Gopher/Go_Error/go%E4%B8%9A%E5%8A%A1%E5%9F%BA%E7%A1%80%E5%BA%93%E4%B9%8BError%26Context/" title="go业务基础库之Error&Context" class="md-nav__link">
      go业务基础库之Error&Context
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../lecture/Gopher/Go%E5%90%8C%E6%AD%A5%E5%92%8C%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/note/" title="Go同步和并发设计模式" class="md-nav__link">
      Go同步和并发设计模式
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../lecture/%E6%8A%80%E6%9C%AF%E6%BC%94%E8%AE%B2/%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90-%E6%88%91%E8%BF%99%E6%8A%80%E6%9C%AF%E4%BA%8C%E5%8D%81%E5%B9%B4/" title="左耳朵耗子-我这技术二十年" class="md-nav__link">
      左耳朵耗子-我这技术二十年
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-27" type="checkbox" id="nav-27">
    
    <label class="md-nav__link" for="nav-27">
      金融理财
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="金融理财" data-md-level="1">
      <label class="md-nav__title" for="nav-27">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        金融理财
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/%E5%AE%9A%E6%8A%95%E5%8D%81%E5%B9%B4/" title="定投十年" class="md-nav__link">
      定投十年
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/" title="穷查理宝典" class="md-nav__link">
      穷查理宝典
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-28" type="checkbox" id="nav-28">
    
    <label class="md-nav__link" for="nav-28">
      写作
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="写作" data-md-level="1">
      <label class="md-nav__title" for="nav-28">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        写作
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E5%86%99%E4%BD%9C/%E5%88%B7%E5%B1%8F%E6%96%87%E6%A1%88%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/" title="刷屏文案写作技巧" class="md-nav__link">
      刷屏文案写作技巧
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-29" type="checkbox" id="nav-29">
    
    <label class="md-nav__link" for="nav-29">
      思维
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="思维" data-md-level="1">
      <label class="md-nav__title" for="nav-29">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        思维
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E4%B8%93%E6%B3%A8%E5%8A%9B_%E5%8C%96%E7%B9%81%E4%B8%BA%E7%AE%80%E7%9A%84%E6%83%8A%E4%BA%BA%E5%8A%9B%E9%87%8F/" title="专注力" class="md-nav__link">
      专注力
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E8%BF%99%E6%A0%B7%E7%94%A8%E8%84%91%E4%B8%8D%E4%BC%9A%E7%B4%AF/" title="为什么精英这样用脑不会累" class="md-nav__link">
      为什么精英这样用脑不会累
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/" title="刻意练习" class="md-nav__link">
      刻意练习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%A6%82%E4%BD%95%E6%83%B3%E5%88%B0%E5%8F%88%E5%81%9A%E5%88%B0/" title="如何想到又做到" class="md-nav__link">
      如何想到又做到
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/" title="学习之道" class="md-nav__link">
      学习之道
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%AD%A6%E4%B9%A0%E5%8A%9B/" title="学习力" class="md-nav__link">
      学习力
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7/" title="批判性思维工具" class="md-nav__link">
      批判性思维工具
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BF%AE%E7%82%BC%28%E5%BC%80%E5%8F%91%E8%AE%A4%E7%9F%A5%E6%BD%9C%E8%83%BD%E7%9A%84%E4%B9%9D%E5%A0%82%E8%AF%BE%29/" title="程序员的思维修炼" class="md-nav__link">
      程序员的思维修炼
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E8%AE%A4%E7%9F%A5%E5%A4%A9%E6%80%A7/" title="认知天性" class="md-nav__link">
      认知天性
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E8%B6%85%E6%95%88%E7%8E%87%E6%89%8B%E5%86%8C/" title="超效率手册" class="md-nav__link">
      超效率手册
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%AE%B0%E5%BF%86/" title="如何高效记忆" class="md-nav__link">
      如何高效记忆
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E7%A7%91%E5%AD%A6%E5%AD%A6%E4%B9%A0/" title="科学学习" class="md-nav__link">
      科学学习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF/" title="高效程序员的45个习惯" class="md-nav__link">
      高效程序员的45个习惯
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-30" type="checkbox" id="nav-30">
    
    <label class="md-nav__link" for="nav-30">
      职场
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="职场" data-md-level="1">
      <label class="md-nav__title" for="nav-30">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        职场
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/give_and_take/" title="give and take" class="md-nav__link">
      give and take
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/the_effective_engineer/" title="the_effective_engineer" class="md-nav__link">
      the_effective_engineer
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E5%85%89%E9%80%9F%E6%88%90%E9%95%BF/" title="光速成长" class="md-nav__link">
      光速成长
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86/" title="向上管理" class="md-nav__link">
      向上管理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E6%88%90%E5%8A%9F%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E6%A0%87/" title="成功动机与目标" class="md-nav__link">
      成功动机与目标
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/" title="番茄工作法" class="md-nav__link">
      番茄工作法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E8%81%86%E5%90%AC%E6%B2%9F%E9%80%9A%E5%AD%A6/" title="聆听沟通学" class="md-nav__link">
      聆听沟通学
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E7%9F%A5%E4%B9%8E%E8%81%8C%E4%BA%BA%E8%A7%89%E9%86%92/" title="知乎职人觉醒" class="md-nav__link">
      知乎职人觉醒
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E7%9F%A5%E8%AF%86%E5%8F%98%E7%8E%B0/" title="知识变现" class="md-nav__link">
      知识变现
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E8%81%86%E5%90%AC%E6%B2%9F%E9%80%9A%E5%AD%A6/" title="聆听沟通学" class="md-nav__link">
      聆听沟通学
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E8%81%8C%E5%9C%BA%E5%8A%A8%E7%89%A9%E8%BF%9B%E5%8C%96%E6%89%8B%E5%86%8C/" title="职场动物进化手册" class="md-nav__link">
      职场动物进化手册
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E8%81%8C%E5%9C%BA%E8%A7%A3%E9%87%8A%E7%B3%BB/" title="职场解释系" class="md-nav__link">
      职场解释系
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E8%AF%B7%E5%81%9C%E6%AD%A2%E6%97%A0%E6%95%88%E5%8A%AA%E5%8A%9B/" title="请停止无效努力" class="md-nav__link">
      请停止无效努力
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E8%BD%AF%E6%8A%80%E8%83%BD/" title="软技能" class="md-nav__link">
      软技能
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E9%AB%98%E6%95%8815%E6%B3%95%E5%88%99/" title="高效15法则" class="md-nav__link">
      高效15法则
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E9%AB%98%E6%95%88%E6%B8%85%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%B3%95/" title="高效清单工作法" class="md-nav__link">
      高效清单工作法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../career/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="程序员的自我修养" class="md-nav__link">
      程序员的自我修养
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-31" type="checkbox" id="nav-31">
    
    <label class="md-nav__link" for="nav-31">
      心理学
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="心理学" data-md-level="1">
      <label class="md-nav__title" for="nav-31">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        心理学
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E7%AB%A5%E5%B9%B4%E7%9A%84%E9%94%99%E5%90%97/" title="一切都是童年的错吗" class="md-nav__link">
      一切都是童年的错吗
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/" title="亲密关系" class="md-nav__link">
      亲密关系
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E6%83%85%E5%95%86/" title="情商" class="md-nav__link">
      情商
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E9%80%86%E5%95%86/" title="逆商" class="md-nav__link">
      逆商
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E6%8B%96%E5%BB%B6%E5%BF%83%E7%90%86%E5%AD%A6/" title="拖延心理学" class="md-nav__link">
      拖延心理学
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/" title="积极心理学" class="md-nav__link">
      积极心理学
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B/" title="自控力" class="md-nav__link">
      自控力
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B-%E5%AE%9E%E6%93%8D%E7%AF%87/" title="自控力-实操篇" class="md-nav__link">
      自控力-实操篇
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B-%E5%92%8C%E5%8E%8B%E5%8A%9B%E5%81%9A%E6%9C%8B%E5%8F%8B/" title="自控力:和压力做朋友" class="md-nav__link">
      自控力:和压力做朋友
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E6%B4%BB%E5%87%BA%E6%9C%80%E4%B9%90%E8%A7%82%E7%9A%84%E8%87%AA%E5%B7%B1/" title="活出最乐观的自己" class="md-nav__link">
      活出最乐观的自己
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E6%94%B9%E5%8F%98%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%8440%E9%A1%B9%E7%A0%94%E7%A9%B6/" title="改变心理学的40项研究" class="md-nav__link">
      改变心理学的40项研究
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E8%B6%85%E8%B6%8A%E8%87%AA%E5%8D%91/" title="超越自卑" class="md-nav__link">
      超越自卑
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../psychology/%E5%8F%8D%E8%84%86%E5%BC%B1/" title="反脆弱" class="md-nav__link">
      反脆弱
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-32" type="checkbox" id="nav-32">
    
    <label class="md-nav__link" for="nav-32">
      创业
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="创业" data-md-level="1">
      <label class="md-nav__title" for="nav-32">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        创业
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../../startup/hello_startup/" title="Hello Startup" class="md-nav__link">
      Hello Startup
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../startup/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%85%AC%E5%BC%80%E8%AF%BE-%E5%A6%82%E4%BD%95%E5%88%9B%E4%B8%9A/" title="斯坦福公开课如何创业" class="md-nav__link">
      斯坦福公开课如何创业
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../../startup/%E8%BF%90%E8%90%A5%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95/" title="运营其实很简单" class="md-nav__link">
      运营其实很简单
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/zwiley/mybook/edit/master/docs/unix_linux/Linux高性能服务器编程/Linux高性能服务器编程.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                  
                
                
                <h1 id="1-tcpip">1章 TCP/IP 协议族详解<a class="headerlink" href="#1-tcpip" title="Permanent link">&para;</a></h1>
<p>linux 使用 /etc/resolv.conf 存放 DNS 服务器的 IP 地址
数据链路层、网络层、传输层在内核实现的，操作系统提供了一组系统调用 api: socket</p>
<h1 id="2-ip">2章 IP 协议详解<a class="headerlink" href="#2-ip" title="Permanent link">&para;</a></h1>
<ul>
<li>IP 头部：出现在每个 IP 数据报中，用于指定 IP 通信的源IP地址、目的IP地址、指导IP 分片和重组</li>
<li>IP 数据报的路由和转发</li>
</ul>
<p>IP协议为上层提供无状态、无连接、不可靠的服务，使用 IP 协议的上层协议（比如TCP）需要自己实现数据确认、超时重传等机制。</p>
<h1 id="3-tcp">3章 TCP 协议详解<a class="headerlink" href="#3-tcp" title="Permanent link">&para;</a></h1>
<h3 id="31-tcp">3.1 TCP 服务的特点<a class="headerlink" href="#31-tcp" title="Permanent link">&para;</a></h3>
<p>面向连接、字节流、可靠传输
字节流：应用程序对数据的发送和接受是没有边界限制的。</p>
<p>TCP: send, recv
UDP: sendto() recvfrom()</p>
<h3 id="32-tcp">3.2 TCP 头部信息<a class="headerlink" href="#32-tcp" title="Permanent link">&para;</a></h3>
<p>RTT: Round Trip Time
可以用 tcpdump 工具来检查</p>
<p>TCP状态转移，当前状态可以用 netstat 命令查看</p>
<p>如果客户端向处于半打开状态的连接写入数据，对方将回应一个复位报文段</p>
<h1 id="4-tcpip-internet-web">4 TCP/IP 通信案例:访问 Internet 上的 web 服务<a class="headerlink" href="#4-tcpip-internet-web" title="Permanent link">&para;</a></h1>
<p>使用了 squid http 代理服务器.
- 正向代理：客户端自己设置代理服务器地址。每次请求发给代理服务器，由代理服务器请求资源
- 反向代理：设置在服务端，用代理服务器接受连接请求，然后请求转发给内部网络上的服务器。所以不同地方 ping 一个域名可能获取到不同的 ip 地址
- 透明代理：只能设置在网关上。可以看做正向代理的一种特殊情况</p>
<p>HTTP 应用层协议，一般使用 TCP 协议作为传输层。 wget 用 squid 代理服务器 tcpdump -X 抓包</p>
<h1 id="5-linux-api">5 Linux 网络编程基础 API<a class="headerlink" href="#5-linux-api" title="Permanent link">&para;</a></h1>
<h3 id="51-socket-api">5.1 socket 地址 API<a class="headerlink" href="#51-socket-api" title="Permanent link">&para;</a></h3>
<p>主机字节序：现代 cpu 一次能装载至少4个字节，这 4 个字节在内存中的排列顺序影响它被累加器装载成的整数的值
分为
- 大端字节序(big endian) : 一个整数的高位字节存储在内存的低地址处
- 小端字节序(little endian): 高位字节存储在高地址处</p>
<p>现在pc大多采用小端字节序（也被称为主机字节序）。
不同字节序在网络之间传输会有问题，解决方法是发送端总是转成大端字节序，接收端自行决定是否要转换。大端字节序也因此成为
网络字节序。linux 提供了 4 个函数完成主机字节序（小端）和网络字节序（大端）的转换：
(python socket.htonl)</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># include &lt;netinet.h&gt;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">htonl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span>  <span class="n">hostlong</span><span class="p">)</span>  <span class="c1">// host to network long</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">htons</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span>  <span class="n">hostshort</span><span class="p">)</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">ntoh</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">netlong</span><span class="p">)</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">ntohs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">netshort</span><span class="p">)</span>
</code></pre></div>


<p>socket 编程接口中表示 socket 地址的结构 sockaddr:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;bits/socket.h&gt;</span><span class="cp"></span>
<span class="k">struct</span> <span class="n">sockaddr</span><span class="p">{</span>
<span class="n">sa_family_t</span> <span class="n">sa_family</span><span class="p">;</span>   <span class="c1">// 地址族 AF_UNIX, AF_INET, AF_INET6</span>
<span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span>  <span class="c1">// 存放 socket 地址</span>
<span class="p">}</span>
</code></pre></div>


<p>ip 地址转换</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜arpa/inet.h＞</span><span class="cp"></span>
<span class="n">in_addr_t</span> <span class="nf">inet_addr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">strptr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">inet_aton</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">cp</span><span class="p">,</span><span class="k">struct</span> <span class="n">in_addr</span><span class="o">*</span><span class="n">inp</span><span class="p">);</span>
<span class="kt">char</span><span class="o">*</span><span class="nf">inet_ntoa</span><span class="p">(</span><span class="k">struct</span> <span class="n">in_addr</span> <span class="n">in</span><span class="p">);</span>
</code></pre></div>


<h3 id="52-socket">5.2 创建 socket<a class="headerlink" href="#52-socket" title="Permanent link">&para;</a></h3>
<p>unix 一切皆文件， socket 就是可读、可写、可控制、可关闭的文件描述符</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span><span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>
</code></pre></div>


<h3 id="53-socket">5.3 命名 socket<a class="headerlink" href="#53-socket" title="Permanent link">&para;</a></h3>
<p>将一个 socket 和socket 地址绑定称为给 socket 命名。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="n">my_addr</span><span class="p">,</span><span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></div>


<h3 id="54-socket">5.4 监听 socket<a class="headerlink" href="#54-socket" title="Permanent link">&para;</a></h3>
<p>bind 后还需要创建一个监听队列存放待处理的客户端连接</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>
</code></pre></div>


<p>监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。在内核版本2.2之前的Linux中，backlog参数是指所有处于半连接状态（SYN_RCVD）和完全连接状态（ESTABLISHED）的socket的上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义。backlog参数的典型值是5。</p>
<h3 id="55">5.5 接受连接<a class="headerlink" href="#55" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
</code></pre></div>


<p>accept 成功时返回一个新的连接 socket，其唯一标识了被接受的这个连接，服务器可以通过读写该 socket 来与被接受连接
的对应客户端通信。
注意 accept 只是从监听队列中取出连接，而不论连接处于何种状态，更不关心网络的变化。
我们把执行过listen调用、处于 LISTEN 状态的 socket 称为监听 socket， 而所有处于 ESTABLISHED 状态的 socket 称为
连接socket.</p>
<h3 id="56">5.6 发起连接<a class="headerlink" href="#56" title="Permanent link">&para;</a></h3>
<p>服务器通过listen 被动接受连接，客户端需要通过 connect 主动与服务器建立连接</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">serv_addr</span><span class="p">,</span> <span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>
</code></pre></div>


<p>一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和ETIMEDOUT，</p>
<h3 id="57">5.7 关闭连接<a class="headerlink" href="#57" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>  <span class="c1">// fd 引用计数-1</span>
</code></pre></div>


<p>有个专门为网络编程设计的函数，无论如何都会立即终止连接</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">shutdown</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">howto</span><span class="p">)</span>  <span class="c1">// SHUT_RD, SHUT_WR, SHUT_RDWR</span>
</code></pre></div>


<h3 id="58-socket">5.8 socket 数据读写<a class="headerlink" href="#58-socket" title="Permanent link">&para;</a></h3>
<p>对于文件读写操作 read/write 同样适用于socket，不过socket 提供了专门的系统调用</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">recv</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">send</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>


<p>udp 数据包读写系统调用（亦可以用于 stream）:</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">recvfrom</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">,</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="n">src_addr</span><span class="p">,</span><span class="kt">socklen_t</span><span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">sendto</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="n">dest_addr</span><span class="p">,</span><span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">)</span>
</code></pre></div>


<p>通用数据读写函数：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">recvmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">struct</span> <span class="n">msghdr</span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="nf">sendmsg</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">struct</span> <span class="n">msghdr</span><span class="o">*</span><span class="n">msg</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>


<h1 id="59">5.9 带外标记<a class="headerlink" href="#59" title="Permanent link">&para;</a></h1>
<p>linux 检测到 TCP 紧急标志时，将通知应用程序有带外数据需要接收。内核通知应用程序带外数据到达有两种常见方式：
I/O复用产生的异常事件和 SIGURG 信号</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">sockatmark</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">);</span>
</code></pre></div>


<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用带MSG_OOB标志的recv调用来接收带外数据。如果不是，则sockatmark返回0。</p>
<h1 id="510">5.10 地址信息函数<a class="headerlink" href="#510" title="Permanent link">&para;</a></h1>
<p>同样 python 在 socket 模块可以查到</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="c1">// 获取 sockfd 对应的本端 socket 地址，存储在aaddress 参数指定的内存中</span>
<span class="kt">int</span> <span class="nf">getsockname</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="kt">socklen_t</span><span class="o">*</span><span class="n">address_len</span><span class="p">);</span>
<span class="c1">// 获取 sockfd 对应的远端 socket 地址</span>
<span class="kt">int</span> <span class="nf">getpeername</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="n">address</span><span class="p">,</span><span class="kt">socklen_t</span><span class="o">*</span><span class="n">address_len</span><span class="p">);</span>
</code></pre></div>


<h1 id="511-socket">5.11 socket 选项<a class="headerlink" href="#511-socket" title="Permanent link">&para;</a></h1>
<p>下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">getsockopt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span><span class="kt">int</span> <span class="n">option_name</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">option_value</span><span class="p">,</span><span class="kt">socklen_t</span><span class="o">*</span><span class="kr">restrict</span> <span class="n">option_len</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">setsockopt</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">level</span><span class="p">,</span><span class="kt">int</span> <span class="n">option_name</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="n">option_value</span><span class="p">,</span><span class="kt">socklen_t</span> <span class="n">option_len</span><span class="p">);</span>
</code></pre></div>


<p>常用:
- SO_REUSEADDR: 强制使用被处于 TIME_WAIT 状态的连接占用的 socket 地址
- SO_RCVBUF/SO_SNDBUF: 表示TCP 接收缓冲区和发送缓冲区的大小
- SO_RECLOWAT/SO_SNDLOWAT: 表示TCP 接收缓冲区和发送缓冲区的低水位标记，一般被I/O
  复用系统调用用来判断socket是否可读或者可写（默认1字节）
- SO_LINGER: 控制close系统调用在关闭TCP连接时候的行为</p>
<p># 5.12 网络信息 API</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜netdb.h＞</span><span class="cp"></span>
<span class="c1">// 根据主机名获取主机的完整信息</span>
<span class="k">struct</span> <span class="n">hostent</span><span class="o">*</span><span class="nf">gethostbyname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="c1">// 根据 IP 地址获取主机的完整信息</span>
<span class="k">struct</span> <span class="n">hostent</span><span class="o">*</span><span class="nf">gethostbyaddr</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="n">addr</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span><span class="kt">int</span> <span class="n">type</span><span class="p">);</span>

<span class="c1">//getservbyname函数根据名称获取某个服务的完整信息，</span>
<span class="k">struct</span> <span class="n">servent</span><span class="o">*</span><span class="nf">getservbyname</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">proto</span><span class="p">);</span>
<span class="c1">// getservbyport函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取/etc/services文件来获取服务的信息的</span>
<span class="k">struct</span> <span class="n">servent</span><span class="o">*</span><span class="nf">getservbyport</span><span class="p">(</span><span class="kt">int</span> <span class="n">port</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">proto</span><span class="p">);</span>

<span class="c1">// getaddrinfo函数既能通过主机名获取ip地址，也能通过服务名获取端口号</span>
<span class="kt">int</span> <span class="nf">getaddrinfo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">hostname</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">service</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">addrinfo</span><span class="o">*</span><span class="n">hints</span><span class="p">,</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="o">**</span><span class="n">result</span><span class="p">);</span>

<span class="c1">// getnameinfo函数能通过socket地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数）</span>
<span class="kt">int</span> <span class="nf">getnameinfo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="n">sockaddr</span><span class="p">,</span><span class="kt">socklen_t</span> <span class="n">addrlen</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">host</span><span class="p">,</span><span class="kt">socklen_t</span> <span class="n">hostlen</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">serv</span><span class="p">,</span><span class="kt">socklen_t</span> <span class="n">servlen</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>


<p>上述4个函数都是不可重入的，即非线程安全的。 <netdb.h> 给出了可重入版本</p>
<h1 id="6-io">6 高级 IO 函数<a class="headerlink" href="#6-io" title="Permanent link">&para;</a></h1>
<h1 id="61-pipe">6.1 pipe 函数<a class="headerlink" href="#61-pipe" title="Permanent link">&para;</a></h1>
<p>创建一个管道以实现进程间通信</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="n">inf</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>  <span class="c1">// f[0] 只能用于从管道读取数据， f[1] 写数据</span>

<span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">socketpair</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span><span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
</code></pre></div>


<h1 id="62-dupdup2">6.2 dup/dup2 函数<a class="headerlink" href="#62-dupdup2" title="Permanent link">&para;</a></h1>
<p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制文件描述符的dup或dup2函数来实现：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">dup</span><span class="p">(</span><span class="kt">int</span> <span class="n">file_descriptor</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">dup2</span><span class="p">(</span><span class="kt">int</span> <span class="n">file_descriptor_one</span><span class="p">,</span><span class="kt">int</span> <span class="n">file_descriptor_two</span><span class="p">);</span>
</code></pre></div>


<p>dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回的文件描述符总是取系统当前可用的最小整数值。dup2和dup类似，不过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统调用失败时返回-1并设置errno。</p>
<h1 id="63-readvwritev">6.3 readv/writev 函数<a class="headerlink" href="#63-readvwritev" title="Permanent link">&para;</a></h1>
<p>readv函数将数据从文件描述符读到分散的内存块中，即分散读；writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。它们的定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/uio.h＞</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">readv</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span><span class="o">*</span><span class="n">vector</span><span class="p">,</span><span class="kt">int</span> <span class="n">count</span><span class="p">)</span><span class="err">；</span>
<span class="kt">ssize_t</span> <span class="n">writev</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span><span class="o">*</span><span class="n">vector</span><span class="p">,</span><span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div>


<h1 id="64-sendfile">6.4 sendfile 函数<a class="headerlink" href="#64-sendfile" title="Permanent link">&para;</a></h1>
<p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。sendfile函数的定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/sendfile.h＞</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">sendfile</span><span class="p">(</span><span class="kt">int</span> <span class="n">out_fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">in_fd</span><span class="p">,</span><span class="kt">off_t</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
</code></pre></div>


<p>in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。offset参数指定从读入文件流的哪个位置开始读，如果为空，则使用读入文件流默认的起始位置。count参数指定在文件描述符in_fd和out_fd之间传输的字节数。sendfile成功时返回传输的字节数，失败则返回-1并设置errno。该函数的man手册明确指出，in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。由此可见，sendfile几乎是专门为在网络上传输文件而设计的。</p>
<h1 id="65-mmapmunmap">6.5 mmap/munmap 函数<a class="headerlink" href="#65-mmapmunmap" title="Permanent link">&para;</a></h1>
<p>mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中。munmap函数则释放由mmap创建的这段内存空间。它们的定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/mman.h＞</span><span class="cp"></span>
<span class="kt">void</span><span class="o">*</span><span class="nf">mmap</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="n">start</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span><span class="kt">int</span> <span class="n">prot</span><span class="p">,</span><span class="kt">int</span> <span class="n">flags</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">off_t</span> <span class="n">offset</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">munmap</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="n">start</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">length</span><span class="p">);</span>
</code></pre></div>


<h1 id="66-splice">6.6 splice 函数<a class="headerlink" href="#66-splice" title="Permanent link">&para;</a></h1>
<p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操作。splice函数的定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜fcntl.h＞</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">splice</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd_in</span><span class="p">,</span><span class="n">loff_t</span><span class="o">*</span><span class="n">off_in</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd_out</span><span class="p">,</span><span class="n">loff_t</span><span class="o">*</span><span class="n">off_out</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>


<h1 id="67-tee">6.7 tee<a class="headerlink" href="#67-tee" title="Permanent link">&para;</a></h1>
<p>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作。tee函数的原型如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜fcntl.h＞</span><span class="cp"></span>
<span class="kt">ssize_t</span> <span class="nf">tee</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd_in</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd_out</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</code></pre></div>


<h1 id="68-fcntl-file-control">6.8 fcntl 函数 (file control)<a class="headerlink" href="#68-fcntl-file-control" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜fcntl.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">fcntl</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span><span class="err">…</span><span class="p">);</span>
</code></pre></div>


<h1 id="7-linux">7 Linux 服务器程序规范<a class="headerlink" href="#7-linux" title="Permanent link">&para;</a></h1>
<h3 id="71">7.1 日志<a class="headerlink" href="#71" title="Permanent link">&para;</a></h3>
<p>linux 提供一个守护进程 来处理日志系统 rsyslogd
应用程序使用syslog函数与rsyslogd守护进程通信。syslog函数的定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜syslog.h＞</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">syslog</span><span class="p">(</span><span class="kt">int</span> <span class="n">priority</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">message</span><span class="p">,...);</span>
</code></pre></div>


<h3 id="72">7.2 用户信息<a class="headerlink" href="#72" title="Permanent link">&para;</a></h3>
<p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分服务器就必须以root身份启动，但不能以root身份运行。下面这一组函数可以获取和设置当前进程的真实用户ID（UID）、有效用户ID（EUID）、真实组ID（GID）和有效组ID（EGID）：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="kt">uid_t</span> <span class="nf">getuid</span><span class="p">();</span><span class="cm">/*获取真实用户ID*/</span><span class="p">,</span>
<span class="kt">uid_t</span> <span class="n">geteuid</span><span class="p">();</span><span class="cm">/*获取有效用户ID*/</span>
<span class="kt">gid_t</span> <span class="nf">getgid</span><span class="p">();</span><span class="cm">/*获取真实组ID*/</span>
<span class="kt">gid_t</span> <span class="nf">getegid</span><span class="p">();</span><span class="cm">/*获取有效组ID*/</span>
<span class="kt">int</span> <span class="nf">setuid</span><span class="p">(</span><span class="kt">uid_t</span> <span class="n">uid</span><span class="p">);</span><span class="cm">/*设置真实用户ID*/</span>
<span class="kt">int</span> <span class="nf">seteuid</span><span class="p">(</span><span class="kt">uid_t</span> <span class="n">uid</span><span class="p">);</span><span class="cm">/*设置有效用户ID*/</span>
<span class="kt">int</span> <span class="nf">setgid</span><span class="p">(</span><span class="kt">gid_t</span> <span class="n">gid</span><span class="p">);</span><span class="cm">/*设置真实组ID*/</span>
<span class="kt">int</span> <span class="nf">setegid</span><span class="p">(</span><span class="kt">gid_t</span> <span class="n">gid</span><span class="p">);</span><span class="cm">/*设置有效组ID*/</span>
</code></pre></div>


<h3 id="73">7.3 进程间关系<a class="headerlink" href="#73" title="Permanent link">&para;</a></h3>
<p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的PGID：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="kt">pid_t</span> <span class="nf">getpgid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">);</span>
</code></pre></div>


<p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的PGID：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="kt">pid_t</span> <span class="nf">getpgid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">);</span>
</code></pre></div>


<h3 id="74">7.4 系统资源限制<a class="headerlink" href="#74" title="Permanent link">&para;</a></h3>
<p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制（CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具体实现的限制（比如文件名的最大长度）。Linux系统资源限制可以通过如下一对函数来读取和设置：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/resource.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">getrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span><span class="k">struct</span> <span class="n">rlimit</span><span class="o">*</span><span class="n">rlim</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">setrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">rlimit</span><span class="o">*</span><span class="n">rlim</span><span class="p">);</span>
</code></pre></div>


<h3 id="75">7.5 改变工作目录和根目录<a class="headerlink" href="#75" title="Permanent link">&para;</a></h3>
<p>获取进程当前工作目录和改变进程工作目录的函数分别是：</p>
<div class="codehilite"><pre><span></span><code><span class="cp"># include＜unistd.h＞</span>
<span class="kt">char</span><span class="o">*</span><span class="nf">getcwd</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">chdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">path</span><span class="p">);</span>
</code></pre></div>


<h3 id="76">7.6 服务器程序后台化<a class="headerlink" href="#76" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">daemon</span><span class="p">(</span><span class="kt">int</span> <span class="n">nochdir</span><span class="p">,</span><span class="kt">int</span> <span class="n">noclose</span><span class="p">);</span>
</code></pre></div>


<h1 id="8">8 高性能服务器程序框架<a class="headerlink" href="#8" title="Permanent link">&para;</a></h1>
<ul>
<li>I/O 处理单元: 四种 IO 模型，两种高效事件处理模式</li>
<li>逻辑单元: 两种高效的并发模式，以及高效的逻辑处理方式-有限状态机</li>
<li>存储单元</li>
</ul>
<h3 id="81">8.1 服务器模型<a class="headerlink" href="#81" title="Permanent link">&para;</a></h3>
<ul>
<li>C/S 模型: server 端压力大</li>
<li>P2P 模型: 网络负载高 (可以看成C/S 模型的扩展)</li>
</ul>
<h3 id="82">8.2 服务器编程框架<a class="headerlink" href="#82" title="Permanent link">&para;</a></h3>
<ul>
<li>IO 处理单元：服务器管理客户端连接的框架，通常等待并接受新的客户端连接，接受客户端数据，将服务器响应返回给客户端.
但是数据收发不一定在IO 处理单元，也可能在逻辑单元中执行，取决于事件处理模式。</li>
<li>逻辑单元：通常是一个线程或者进程，分析并处理客户端数据，然后把结果传递给 IO 处理单元或者直接发送客户端</li>
<li>网络存储单元：数据库、缓存、文件等，非必须的</li>
<li>请求队列：各单元之间的通信方式的抽象，通常被实现为池的一部分。对于服务器机群，请求队列是服务器之间预先建立、静态的、永久的
TCP 连接</li>
</ul>
<h3 id="83-io">8.3 I/O 模型<a class="headerlink" href="#83-io" title="Permanent link">&para;</a></h3>
<p>socket 创建的时候默认是阻塞的，可以传递参数设置成非阻塞。</p>
<p>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。比如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。socket的基础API中，可能被阻塞的系统调用包括accept、send、recv和connect。</p>
<p>针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时我们必须根据errno来区分这两种情况。对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS</p>
<p>很显然，我们只有在事件已经发生的情况下操作非阻塞I/O（读、写等），才能提高程序的效率。因此，非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p>
<p>I/O复用是最常使用的I/O通知机制。它指的是，应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。Linux上常用的I/O复用函数是select、poll和epoll_wait，我们将在第9章详细讨论它们。需要指出的是，I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</p>
<h3 id="84">8.4 两种高效的事件处理模式<a class="headerlink" href="#84" title="Permanent link">&para;</a></h3>
<p>服务器程序通常需要处理三类事件 I/O 事件、信号及定时事件。
两种高效事件处理模式：</p>
<ul>
<li>Reactor: 同步 I/O 模型通常用于实现 Reactor
 Reactor是这样一种模式，它要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</li>
</ul>
<p>使用同步I/O模型（以epoll_wait为例）实现的Reactor模式的工作流程是：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img alt="" src="../reactor.png" /></p>
<ul>
<li>Proactor: 异步 I/O 模型则用于实现 Proactor 模式。与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。因此，Proactor模式更符合图8-4所描述的服务器编程框架。</li>
</ul>
<p>使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模式的工作流程是：</p>
<ol>
<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。</li>
</ol>
<p><img alt="" src="../proactor.png" /></p>
<ul>
<li>使用同步方式模拟 Proactor 模式。 其原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</li>
</ul>
<p>使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式的工作流程如下：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li>
</ol>
<p><img alt="" src="../epoll_proactor.png" /></p>
<h3 id="85">8.5 两种高效的并发模式<a class="headerlink" href="#85" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>半同步/半异步(half-sync/half-async): 同步线程用来处理客户逻辑，异步线程处理I/O事件
<img alt="" src="../half-sync_half-reactive.png" /></p>
</li>
<li>
<p>领导者/追随者(Leader/Followers):领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。
<img alt="" src="../leader_followers.png" /></p>
</li>
</ul>
<h3 id="86">8.6 有限状态机<a class="headerlink" href="#86" title="Permanent link">&para;</a></h3>
<p>逻辑单元内部的一种高效编程方法</p>
<h3 id="87">8.7 提高服务器性能的其他建议<a class="headerlink" href="#87" title="Permanent link">&para;</a></h3>
<ul>
<li>池(pool):空间换时间，预先创建并且初始化资源。内存池、进程池、线程池、连接池</li>
<li>用户复制：减少不必要的数据复制，尤其是在用户代码和内核之间，零拷贝函数。工作进程之间应该考虑共享内存而不是管道或者消息队列.</li>
<li>上下文切换和锁：进程或者线程切换开销；共享资源加锁保护导致服务器效率低下（减小锁的粒度）</li>
</ul>
<h1 id="9-io">9章 I/O 复用<a class="headerlink" href="#9-io" title="Permanent link">&para;</a></h1>
<p>I/O 复用使程序能同时监听多个文件描述符，但是它本身是阻塞的，并且当多个文件描述符同时就绪的时候，如果不采用额外措施，
程序只能依次处理其中的每一个文件描述符，如果要实现并发就要用多进程或多线程等编程手段</p>
<h3 id="91-select">9.1 select 系统调用<a class="headerlink" href="#91-select" title="Permanent link">&para;</a></h3>
<p>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/select.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span><span class="n">fd_set</span><span class="o">*</span><span class="n">readfds</span><span class="p">,</span><span class="n">fd_set</span><span class="o">*</span><span class="n">writefds</span><span class="p">,</span><span class="n">fd_set</span><span class="o">*</span><span class="n">exceptfds</span><span class="p">,</span><span class="k">struct</span> <span class="n">timeval</span><span class="o">*</span><span class="n">timeout</span><span class="p">);</span>
</code></pre></div>


<p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常，对于select的使用非常关键。在网络编程中，下列情况下socket可读：</p>
<p>❑socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</p>
<p>❑socket通信的对方关闭连接。此时对该socket的读操作将返回0。</p>
<p>❑监听socket上有新的连接请求。</p>
<p>❑socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p>
<p>下列情况下socket可写：</p>
<p>❑socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</p>
<p>❑socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</p>
<h3 id="92-poll">9.2 poll 系统调用<a class="headerlink" href="#92-poll" title="Permanent link">&para;</a></h3>
<p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。poll的原型如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜poll.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span><span class="o">*</span><span class="n">fds</span><span class="p">,</span><span class="kt">nfds_t</span> <span class="n">nfds</span><span class="p">,</span><span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">pollfd</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span><span class="cm">/*文件描述符*/</span>
  <span class="kt">short</span> <span class="n">events</span><span class="p">;</span><span class="cm">/*注册的事件*/</span>
  <span class="kt">short</span> <span class="n">revents</span><span class="p">;</span><span class="cm">/*实际发生的事件，由内核填充*/</span>
<span class="p">};</span>
</code></pre></div>


<h3 id="93-epoll">9.3 epoll 系列系统调用<a class="headerlink" href="#93-epoll" title="Permanent link">&para;</a></h3>
<p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用如下epoll_create函数来创建：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/epoll.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">epoll_create</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
</code></pre></div>


<p>size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。下面的函数用来操作epoll的内核事件表：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/epoll.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">epoll_ctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span><span class="kt">int</span> <span class="n">op</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="k">struct</span> <span class="n">epoll_event</span>
<span class="p">{</span>
<span class="n">__uint32_t</span> <span class="n">events</span><span class="p">;</span><span class="cm">/*epoll事件*/</span>
<span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span><span class="cm">/*用户数据*/</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span>
<span class="p">{</span>
<span class="kt">void</span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
<span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
<span class="p">}</span><span class="n">epoll_data_t</span><span class="p">;</span>
</code></pre></div>


<p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/epoll.h＞</span><span class="cp"></span>
<span class="c1">// 该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno。</span>
<span class="kt">int</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="kt">int</span> <span class="n">epfd</span><span class="p">,</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="o">*</span><span class="n">events</span><span class="p">,</span><span class="kt">int</span> <span class="n">maxevents</span><span class="p">,</span><span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span>
</code></pre></div>


<p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。LT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。</p>
<p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。</p>
<p>我们期望的是一个socket连接在任一时刻都只被一个线程处理。这一点可以使用epoll的EPOLLONESHOT事件实现。</p>
<h3 id="94-io">9.4 三组 I/O 复用函数的比较<a class="headerlink" href="#94-io" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../io_diff.png" /></p>
<h3 id="95-io-connect">9.5 I/O 复用高级应用一：非阻塞 connect<a class="headerlink" href="#95-io-connect" title="Permanent link">&para;</a></h3>
<h3 id="98-xinetd">9.8 超级服务 xinetd<a class="headerlink" href="#98-xinetd" title="Permanent link">&para;</a></h3>
<p>Linux因特网服务inetd是超级服务。它同时管理着多个子服务，即监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版本xinetd</p>
<p><img alt="" src="../xinetd.png" /></p>
<h1 id="10">10章 信号<a class="headerlink" href="#10" title="Permanent link">&para;</a></h1>
<h3 id="101-linux">10.1 Linux 信号概述<a class="headerlink" href="#101-linux" title="Permanent link">&para;</a></h3>
<p>Linux下，一个进程给其他进程发送信号的API是kill函数。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜signal.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">kill</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span><span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
</code></pre></div>


<p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号处理函数的原型如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜signal.h＞</span><span class="cp"></span>
<span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">__sighandler_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div>


<p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。信号处理函数应该是可重入的，否则很容易引发一些竞态条件。所以在信号处理函数中严禁调用一些不安全的函数。</p>
<h3 id="102-signal">10.2 signal 系统调用<a class="headerlink" href="#102-signal" title="Permanent link">&para;</a></h3>
<p>要为一个信号设置处理函数，可以使用下面的signal系统调用：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜signal.h＞</span><span class="cp"></span>
<span class="n">_sighandler_t</span> <span class="n">signal</span><span class="p">(</span><span class="kt">int</span>　<span class="n">sig</span><span class="p">,</span><span class="n">_sighandler_t_handler</span><span class="p">)</span>
</code></pre></div>


<p>设置信号处理函数的更健壮的接口是如下的系统调用：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜signal.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">sigaction</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sigaction</span><span class="o">*</span><span class="n">act</span><span class="p">,</span><span class="k">struct</span> <span class="n">sigaction</span><span class="o">*</span><span class="n">oact</span><span class="p">);</span>
</code></pre></div>


<h3 id="103">10.3 信号集函数<a class="headerlink" href="#103" title="Permanent link">&para;</a></h3>
<p>Linux使用数据结构sigset_t来表示一组信号。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜bits/sigset.h＞</span><span class="cp"></span>
<span class="cp">#define_SIGSET_NWORDS(1024/(8*sizeof(unsigned long int)))</span>
<span class="k">typedef</span> <span class="k">struct</span>
<span class="p">{</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">int__val</span><span class="p">[</span><span class="n">_SIGSET_NWORDS</span><span class="p">];</span>
<span class="p">}</span><span class="n">__sigset_t</span><span class="p">;</span>
</code></pre></div>


<h3 id="104">10.4 统一事件源<a class="headerlink" href="#104" title="Permanent link">&para;</a></h3>
<p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处理期间，系统不会再次触发它）太久。一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用管道来将信号“传递”给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么主循环怎么知道管道上何时有数据可读呢?这很简单，我们只需要使用I/O复用系统调用来监听管道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他I/O事件一样被处理，即统一事件源。</p>
<p>很多优秀的I/O框架库和后台服务器程序都统一处理信号和I/O事件，比如Libevent I/O框架库和xinetd超级服务。</p>
<h3 id="105">10.5 网络编程相关信号<a class="headerlink" href="#105" title="Permanent link">&para;</a></h3>
<ul>
<li>SIGHUP: 当挂起进程的控制终端时， SIGHUP 信号将被触发，对于没有控制终端的网络后台程序而言，它们通常利用该信号来强制服务器重新读取配置文件</li>
<li>SIGPIPE: 默认往一个读端关闭的管道或者socket连接中写数据将引发 SIGPIPE 信号</li>
<li>SIGURG: 在Linux环境下，内核通知应用程序带外数据到达主要有两种方法：一种是第9章介绍的I/O复用技术，select等系统调用在接收到带外数据时将返回，并向应用程序报告socket上的异常事件，代码清单9-1给出了一个这方面的例子；另外一种方法就是使用SIGURG信号</li>
</ul>
<h1 id="11">11章 定时器<a class="headerlink" href="#11" title="Permanent link">&para;</a></h1>
<p>两种高效的管理定时器的容器：时间轮和时间堆</p>
<h3 id="111-socket-so_rcvtimeo-so_sndtimeo">11.1 socket 选项 SO_RCVTIMEO 和 SO_SNDTIMEO<a class="headerlink" href="#111-socket-so_rcvtimeo-so_sndtimeo" title="Permanent link">&para;</a></h3>
<p><img alt="" src="../timeo.png" /></p>
<p>在程序中，我们可以根据系统调用（send、sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断超时时间是否已到，进而决定是否开始处理定时任务。</p>
<h3 id="112-sigalrm">11.2 SIGALRM 信号<a class="headerlink" href="#112-sigalrm" title="Permanent link">&para;</a></h3>
<p>第10章提到，由alarm和setitimer函数设置的实时闹钟一旦超时，将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来处理定时任务。但是，如果要处理多个定时任务，我们就需要不断地触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设置的定时周期T保持不变。如果某个定时任务的超时时间不是T的整数倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周期T反映了定时的精度。</p>
<h3 id="113-io">11.3 I/O 复用系统调用的超时参数<a class="headerlink" href="#113-io" title="Permanent link">&para;</a></h3>
<p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能统一处理信号和I/O事件，也能统一处理定时事件。但是由于I/O复用系统调用可能在超时时间到期之前就返回（有I/O事件发生），所以如果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间，如代码清单11-4所示。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define TIMEOUT 5000</span>
<span class="kt">int</span> <span class="n">timeout</span><span class="o">=</span><span class="n">TIMEOUT</span><span class="p">;</span>
<span class="kt">time_t</span> <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="kt">time_t</span> <span class="n">end</span><span class="o">=</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;the timeout is now%d mil-seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">timeout</span><span class="p">);</span>
    <span class="n">start</span><span class="o">=</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">number</span><span class="o">=</span><span class="n">epoll_wait</span><span class="p">(</span><span class="n">epollfd</span><span class="p">,</span><span class="n">events</span><span class="p">,</span><span class="n">MAX_EVENT_NUMBER</span><span class="p">,</span><span class="n">timeout</span><span class="p">);</span>
    <span class="k">if</span><span class="p">((</span><span class="n">number</span><span class="err">＜</span><span class="mi">0</span><span class="p">)</span><span class="err">＆＆</span><span class="p">(</span><span class="n">errno</span><span class="o">!=</span><span class="n">EINTR</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;epoll failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间*/</span>
    <span class="k">if</span><span class="p">(</span><span class="n">number</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">timeout</span><span class="o">=</span><span class="n">TIMEOUT</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">end</span><span class="o">=</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="cm">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(end-start)*1000 ms，我们需要将定时时间timeout减去这段时间，以获得下次epoll_wait调用的超时参数*/</span>
    <span class="n">timeout</span><span class="o">-=</span><span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">*</span><span class="mi">1000</span><span class="p">;</span>
    <span class="cm">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间*/</span>
    <span class="k">if</span><span class="p">(</span><span class="n">timeout</span><span class="err">＜</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">timeout</span><span class="o">=</span><span class="n">TIMEOUT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//handle connections</span>
<span class="p">}</span>
</code></pre></div>


<h3 id="114">11.4 高性能定时器<a class="headerlink" href="#114" title="Permanent link">&para;</a></h3>
<ul>
<li>时间轮: 指针指向轮子上的一个槽（slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽（虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是N<em>si。每个槽指向一条定时
器链表，每条链表上的定时器具有相同的特征：它们的定时时间相差N</em>si的整数倍。时间轮正是利用这个关系将定时器散列到不同的链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts（timer
slot）对应的链表中：ts=(cs+(ti/si))%N</li>
</ul>
<p><img alt="时间轮" src="../time_wheel.png" /></p>
<ul>
<li>时间堆: 设计定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</li>
</ul>
<h1 id="12-io-libevent">12章 高性能 I/O 框架库 Libevent<a class="headerlink" href="#12-io-libevent" title="Permanent link">&para;</a></h1>
<p>linux服务器必须处理三种事件： I/O事件、信号和定时事件，处理这三类事件时通常需要考虑三个问题：
- 统一事件源。利用 I/O 复用系统调用来管理所有事件
- 可移植性， FreeBSD kqueue, Linux epoll
- 并发编程支持。多进程和多线程下，需要考虑各执行实体如何协同处理客户连接、信号和定时器，避免竞态条件</p>
<h3 id="121-io">12.1 I/O 框架库概述<a class="headerlink" href="#121-io" title="Permanent link">&para;</a></h3>
<p>以 Reactor， Proactor 或者同时以两种模式实现</p>
<p><img alt="I/O框架库组件" src="../io_library.png" /></p>
<p>1.句柄</p>
<p>I/O框架库要处理的对象，即I/O事件、信号和定时事件，统一称为事件源。一个事件源通常和一个句柄绑定在一起。句柄的作用是，当内核检测到就绪事件时，它将通过句柄来通知应用程序这一事件。在Linux环境下，I/O事件对应的句柄是文件描述符，信号事件对应的句柄就是信号值。</p>
<p>2.事件多路分发器</p>
<p>事件的到来是随机的、异步的。我们无法预知程序何时收到一个客户连接请求，又亦或收到一个暂停信号。所以程序需要循环地等待并处理事件，这就是<strong>事件循环</strong>。在事件循环中，等待事件一般使用I/O复用技术来实现。I/O框架库一般将系统支持的各种I/O复用系统调用封装成统一的接口，称为事</p>
<p>件多路分发器。事件多路分发器的demultiplex方法是等待事件的核心函数，其内部调用的是select、poll、epoll_wait等函数。</p>
<p>此外，事件多路分发器还需要实现register_event和remove_event方法，以供调用者往事件多路分发器中添加事件和从事件多路分发器中删除事件。</p>
<p>3.事件处理器和具体事件处理器</p>
<p>事件处理器执行事件对应的业务逻辑。它通常包含一个或多个handle_event回调函数，这些回调函数在事件循环中被执行。I/O框架库提供的事件处理器通常是一个接口，用户需要继承它来实现自己的事件处理器，即具体事件处理器。因此，事件处理器中的回调函数一般被声明为虚函数，以支持用户的扩展。</p>
<p>此外，事件处理器一般还提供一个get_handle方法，它返回与该事件处理器关联的句柄。那么，事件处理器和句柄有什么关系？当事件多路分发器检测到有事件发生时，它是通过句柄来通知应用程序的。因此，我们必须将事件处理器和句柄绑定，才能在事件发生时获取到正确的事件处理器。</p>
<p>4.Reactor</p>
<p>Reactor是I/O框架库的核心。它提供的几个主要方法是：</p>
<p>❑handle_events。该方法执行事件循环。它重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。</p>
<p>❑register_handler。该方法调用事件多路分发器的register_event方法来往事件多路分发器中注册一个事件。</p>
<p>❑remove_handler。该方法调用事件多路分发器的remove_event方法来删除事件多路分发器中的一个事件。</p>
<p><img alt="" src="../time_order.png" /></p>
<h3 id="122-libevent">12.2 Libevent 源码分析<a class="headerlink" href="#122-libevent" title="Permanent link">&para;</a></h3>
<p>从使用方式入手分析代码：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/signal.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜event.h＞</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">signal_cb</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">short</span> <span class="n">event</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">argc</span><span class="p">)</span>  <span class="c1">// 回调函数相当于 handle_event，arg 参数是 Reactor 传递给回调函数的参数</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">event_base</span><span class="o">*</span><span class="n">base</span><span class="o">=</span><span class="p">(</span><span class="n">event_base</span><span class="o">*</span><span class="p">)</span><span class="n">argc</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">delay</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Caught an interrupt signal;exiting cleanly in two seconds...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">event_base_loopexit</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="err">＆</span><span class="n">delay</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">timeout_cb</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span><span class="kt">short</span> <span class="n">event</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">argc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;timeout</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">event_base</span><span class="o">*</span><span class="n">base</span><span class="o">=</span><span class="n">event_init</span><span class="p">();</span>    <span class="c1">// 调用event_init 创建 event_base 对象，一个 event_base 相当于一个 Reactor 实例</span>
    <span class="k">struct</span> <span class="n">event</span><span class="o">*</span><span class="n">signal_event</span><span class="o">=</span><span class="n">evsignal_new</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="n">SIGINT</span><span class="p">,</span><span class="n">signal_cb</span><span class="p">,</span><span class="n">base</span><span class="p">);</span>  <span class="c1">// 创建信号事件处理器</span>
    <span class="n">event_add</span><span class="p">(</span><span class="n">signal_event</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 相当于 register_handler</span>
    <span class="n">timeval</span> <span class="n">tv</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">struct</span> <span class="n">event</span><span class="o">*</span><span class="n">timeout_event</span><span class="o">=</span><span class="n">evtimer_new</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="n">timeout_cb</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 创建定时器事件处理器</span>
    <span class="n">event_add</span><span class="p">(</span><span class="n">timeout_event</span><span class="p">,</span><span class="err">＆</span><span class="n">tv</span><span class="p">);</span>
    <span class="n">event_base_dispatch</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>  <span class="c1">// 调用 event_base_dispatch 执行事件循环</span>

    <span class="n">event_free</span><span class="p">(</span><span class="n">timeout_event</span><span class="p">);</span>
    <span class="n">event_free</span><span class="p">(</span><span class="n">signal_event</span><span class="p">);</span>
    <span class="n">event_base_free</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="13">13章 多进程编程<a class="headerlink" href="#13" title="Permanent link">&para;</a></h1>
<p>进程是Linux操作系统环境的基础，它控制着系统上几乎所有的活动。本章从系统程序员的角度来讨论Linux多进程编程，包括如下内容：</p>
<p>❑复制进程映像的fork系统调用和替换进程映像的exec系列系统调用。</p>
<p>❑僵尸进程以及如何避免僵尸进程。</p>
<p>❑进程间通信（Inter-Process Communication，IPC）最简单的方式：管道。</p>
<p>❑3种System V进程间通信方式：信号量、消息队列和共享内存。它们都是由AT＆T System V2版本的UNIX引入的，所以统称为System V IPC。</p>
<p>❑在进程间传递文件描述符的通用方法：通过UNIX本地域socket传递特殊的辅助数据</p>
<h3 id="131-fork">13.1 fork 系统调用<a class="headerlink" href="#131-fork" title="Permanent link">&para;</a></h3>
<p>Linux下创建新进程的系统调用是fork</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="kt">pid_t</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="o">&lt;</span><span class="n">Paste</span><span class="o">&gt;</span>
</code></pre></div>


<p>该函数的每次调用都返回两次，在父进程中返回的是子进程的PID，在子进程中则返回0。该返回值是后续代码判断当前进程是父进程还是子进程的依据。</p>
<h3 id="132-exec">13.2 exec 系列系统调用<a class="headerlink" href="#132-exec" title="Permanent link">&para;</a></h3>
<p>有时我们需要在子进程中执行其他程序，即替换当前进程映像，这就需要使用如下exec系列函数之一：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="k">extern</span> <span class="kt">char</span><span class="o">**</span><span class="n">environ</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">execl</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">path</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">arg</span><span class="p">,...);</span>
<span class="kt">int</span> <span class="nf">execlp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">arg</span><span class="p">,...);</span>
<span class="kt">int</span> <span class="nf">execle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">path</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">arg</span><span class="p">,...,</span><span class="kt">char</span><span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span>
<span class="kt">int</span> <span class="nf">execv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">path</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[]);</span>
<span class="kt">int</span> <span class="nf">execvp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[]);</span>
<span class="kt">int</span> <span class="nf">execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">path</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[],</span><span class="kt">char</span><span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span>
</code></pre></div>


<h3 id="133">13.3 处理僵尸进程<a class="headerlink" href="#133" title="Permanent link">&para;</a></h3>
<p>如果父进程没有正确地处理子进程的返回信息，子进程都将停留在僵尸态，并占据着内核资源。这是绝对不能容许的，毕竟内核资源有限。下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或者使子进程的僵尸态立即结束：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/wait.h＞</span><span class="cp"></span>
<span class="kt">pid_t</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="n">stat_loc</span><span class="p">);</span>
<span class="kt">pid_t</span> <span class="nf">waitpid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">stat_loc</span><span class="p">,</span><span class="kt">int</span> <span class="n">options</span><span class="p">);</span> <span class="c1">//可以是非阻塞的</span>
</code></pre></div>


<p>wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于stat_loc参数指向的内存中。</p>
<p>当一个进程结束时，它将给其父进程发送一个SIGCHLD信号。因此，我们可以在父进程中捕获SIGCHLD信号，并在信号处理函数中调用waitpid函数以“彻底结束”一个子进程，</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">handle_child</span><span class="p">(</span><span class="kt">int</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>
<span class="k">while</span><span class="p">((</span><span class="n">pid</span><span class="o">=</span><span class="n">waitpid</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="err">＆</span><span class="n">stat</span><span class="p">,</span><span class="n">WNOHANG</span><span class="p">))</span><span class="err">＞</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="cm">/*对结束的子进程进行善后处理*/</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<h3 id="134">13.4 管道<a class="headerlink" href="#134" title="Permanent link">&para;</a></h3>
<p>pipe 也是父子进程之间通信的常用手段</p>
<p><img alt="" src="../pipe.png" /></p>
<h3 id="135">13.5 信号量<a class="headerlink" href="#135" title="Permanent link">&para;</a></h3>
<p>当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占式访问。通常，程序对共享资源的访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件。我们称这段代码为关键代码段，或者<strong>临界区</strong>。对进程同步，也就是确保任一时刻只有一个进程能进入关键代码段。</p>
<p>Dijkstra提出的信号量（Semaphore）概念是并发编程领域迈出的重要一步。信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待（wait）和信号（signal）。不过在Linux/UNIX中，“等待”和“信号”都已经具有特殊的含义，所以对信号量的这两种操作更常用的称呼是P、V操作。这两个字母来自于荷兰语单词passeren（传递，就好像进入临界区）和vrijgeven（释放，就好像退出临界区）。假设有信号量SV，则对它的P、V操作含义如下：</p>
<p>❑P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂起进程的执行。</p>
<p>❑V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1。</p>
<p>注意　使用一个普通变量来模拟二进制信号量是行不通的，因为所有高级语言都没有一个原子操作可以同时完成如下两步操作：检测变量是否为true/false，如果是则再将它设置为false/true。</p>
<p>semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/sem.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">semget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span><span class="kt">int</span> <span class="n">num_sems</span><span class="p">,</span><span class="kt">int</span> <span class="n">sem_flags</span><span class="p">);</span>
</code></pre></div>


<p>semop系统调用改变信号量的值，即执行P、V操作。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">semval</span><span class="p">;</span>
<span class="cm">/*信号量的值*/</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">semzcnt</span><span class="p">;</span>

<span class="cm">/*等待信号量值变为0的进程数量*/</span>
<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">semncnt</span><span class="p">;</span>
<span class="cm">/*等待信号量值增加的进程数量*/</span>
<span class="kt">pid_t</span> <span class="n">sempid</span><span class="p">;</span>
<span class="cm">/*最后一次执行semop操作的进程ID*/</span>

<span class="c1">//semop对信号量的操作实际上就是对这些内核变量的操作。</span>
<span class="kt">int</span> <span class="nf">semop</span><span class="p">(</span><span class="kt">int</span> <span class="n">sem_id</span><span class="p">,</span><span class="k">struct</span> <span class="n">sembuf</span><span class="o">*</span><span class="n">sem_ops</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">num_sem_ops</span><span class="p">);</span>
</code></pre></div>


<p>semctl系统调用允许调用者对信号量进行直接控制。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/sem.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">semctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">sem_id</span><span class="p">,</span><span class="kt">int</span> <span class="n">sem_num</span><span class="p">,</span><span class="kt">int</span> <span class="n">command</span><span class="p">,...);</span>
</code></pre></div>


<p>semget的调用者可以给其key参数传递一个特殊的键值IPC_PRIVATE（其值为0），这样无论该信号量是否已经存在，semget都将创建一个新的信号量。使用该键值创建的信号量并非像它的名字声称的那样是进程私有的。其他进程，尤其是子进程，也有方法来访问这个信号量。所以semget的man手册的BUGS部分上说，使用名字IPC_PRIVATE有些误导（历史原因），应该称为IPC_NEW。</p>
<h3 id="136">13.6 共享内存<a class="headerlink" href="#136" title="Permanent link">&para;</a></h3>
<p>共享内存是最高效的 IPC 机制，不涉及进程之间任何数据传递，但需要同步进程对共享内存的访问，否则会产生静态条件</p>
<p>shmget系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/shm.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">shmget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
</code></pre></div>


<p>如果shmget用于创建共享内存，则这段共享内存的所有字节都被初始化为0，与之关联的内核数据结构shmid_ds将被创建并初始化。shmid_ds结构体</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="n">shmid_ds</span>
<span class="p">{</span>
<span class="k">struct</span> <span class="n">ipc_perm</span> <span class="n">shm_perm</span><span class="p">;</span><span class="cm">/*共享内存的操作权限*/</span>
<span class="kt">size_t</span> <span class="n">shm_segsz</span><span class="p">;</span><span class="cm">/*共享内存大小，单位是字节*/</span>
<span class="n">__time_t</span> <span class="n">shm_atime</span><span class="p">;</span><span class="cm">/*对这段内存最后一次调用shmat的时间*/</span>
<span class="n">__time_t</span> <span class="n">shm_dtime</span><span class="p">;</span><span class="cm">/*对这段内存最后一次调用shmdt的时间*/</span>
<span class="n">__time_t</span> <span class="n">shm_ctime</span><span class="p">;</span><span class="cm">/*对这段内存最后一次调用shmctl的时间*/</span>
<span class="n">__pid_t</span> <span class="n">shm_cpid</span><span class="p">;</span><span class="cm">/*创建者的PID*/</span>
<span class="n">__pid_t</span> <span class="n">shm_lpid</span><span class="p">;</span><span class="cm">/*最后一次执行shmat或shmdt操作的进程的PID*/</span>
<span class="n">shmatt_t</span> <span class="n">shm_nattach</span><span class="p">;</span><span class="cm">/*目前关联到此共享内存的进程数量*/</span>
<span class="cm">/*省略一些填充字段*/</span>
<span class="p">};</span>
</code></pre></div>


<p>共享内存被创建/获取之后，我们不能立即访问它，而是需要先将它关联到进程的地址空间中。使用完共享内存之后，我们也需要将它从进程地址空间中分离。这两项任务分别由如下两个系统调用实现：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/shm.h＞</span><span class="cp"></span>
<span class="kt">void</span><span class="o">*</span><span class="nf">shmat</span><span class="p">(</span><span class="kt">int</span> <span class="n">shm_id</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="n">shm_addr</span><span class="p">,</span><span class="kt">int</span> <span class="n">shmflg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">shmdt</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="n">shm_addr</span><span class="p">);</span>
</code></pre></div>


<p>shmctl系统调用控制共享内存的某些属性。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/shm.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">shmctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">shm_id</span><span class="p">,</span><span class="kt">int</span> <span class="n">command</span><span class="p">,</span><span class="k">struct</span> <span class="n">shmid_ds</span><span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<h3 id="137">13.7 消息队列<a class="headerlink" href="#137" title="Permanent link">&para;</a></h3>
<p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。
msgget系统调用创建一个消息队列，或者获取一个已有的消息队列。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/msg.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">msgget</span><span class="p">(</span><span class="kt">key_t</span> <span class="n">key</span><span class="p">,</span><span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
</code></pre></div>


<p>如果msgget用于创建消息队列，则与之关联的内核数据结构msqid_ds将被创建并初始化。msqid_ds结构体的定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="n">msqid_ds</span>
<span class="p">{</span>
<span class="k">struct</span> <span class="n">ipc_perm</span> <span class="n">msg_perm</span><span class="p">;</span><span class="cm">/*消息队列的操作权限*/</span>
<span class="kt">time_t</span> <span class="n">msg_stime</span><span class="p">;</span><span class="cm">/*最后一次调用msgsnd的时间*/</span>
<span class="kt">time_t</span> <span class="n">msg_rtime</span><span class="p">;</span><span class="cm">/*最后一次调用msgrcv的时间*/</span>
<span class="kt">time_t</span> <span class="n">msg_ctime</span><span class="p">;</span><span class="cm">/*最后一次被修改的时间*/</span>
<span class="kt">unsigned</span> <span class="n">long__msg_cbytes</span><span class="p">;</span><span class="cm">/*消息队列中已有的字节数*/</span>
<span class="n">msgqnum_t</span> <span class="n">msg_qnum</span><span class="p">;</span><span class="cm">/*消息队列中已有的消息数*/</span>
<span class="n">msglen_t</span> <span class="n">msg_qbytes</span><span class="p">;</span><span class="cm">/*消息队列允许的最大字节数*/</span>
<span class="kt">pid_t</span> <span class="n">msg_lspid</span><span class="p">;</span><span class="cm">/*最后执行msgsnd的进程的PID*/</span>
<span class="kt">pid_t</span> <span class="n">msg_lrpid</span><span class="p">;</span><span class="cm">/*最后执行msgrcv的进程的PID*/</span>
<span class="p">};</span>
</code></pre></div>


<p>msgsnd系统调用把一条消息添加到消息队列中。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/msg.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">msgsnd</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span><span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="n">msg_ptr</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">msg_sz</span><span class="p">,</span><span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">msgbuf</span>
<span class="p">{</span>
<span class="kt">long</span> <span class="n">mtype</span><span class="p">;</span><span class="cm">/*消息类型*/</span>
<span class="kt">char</span> <span class="n">mtext</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span><span class="cm">/*消息数据*/</span>
<span class="p">};</span>
</code></pre></div>


<p>msgrcv系统调用从消息队列中获取消息。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/msg·h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">msgrcv</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">msg_ptr</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">msg_sz</span><span class="p">,</span><span class="kt">long</span> <span class="kt">int</span> <span class="n">msgtype</span><span class="p">,</span><span class="kt">int</span> <span class="n">msgflg</span><span class="p">);</span>
</code></pre></div>


<p>msgctl系统调用控制消息队列的某些属性。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜sys/msg.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">msgctl</span><span class="p">(</span><span class="kt">int</span> <span class="n">msqid</span><span class="p">,</span><span class="kt">int</span> <span class="n">command</span><span class="p">,</span><span class="k">struct</span> <span class="n">msqid_ds</span><span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</code></pre></div>


<h3 id="138-ipc">13.8 IPC 命令<a class="headerlink" href="#138-ipc" title="Permanent link">&para;</a></h3>
<p>上述3种System V IPC进程间通信方式都使用一个全局唯一的键值（key）来描述一个共享资源。当程序调用semget、shmget或者msgget时，就创建了这些共享资源的一个实例。Linux提供了ipcs命令，以观察当前系统上拥有哪些共享资源实例。</p>
<div class="codehilite"><pre><span></span><code><span class="err">$</span><span class="n">sudo</span> <span class="n">ipcs</span>
<span class="o">------</span><span class="n">Shared</span> <span class="n">Memory</span> <span class="n">Segments</span><span class="o">--------</span>
<span class="n">key</span> <span class="n">shmid</span> <span class="n">owner</span> <span class="n">perms</span> <span class="n">bytes</span> <span class="n">nattch</span> <span class="n">status</span>
<span class="o">------</span><span class="n">Semaphore</span> <span class="n">Arrays</span><span class="o">--------</span>
<span class="n">key</span> <span class="n">semid</span> <span class="n">owner</span> <span class="n">perms</span> <span class="n">nsems</span>
<span class="mh">0x00000000</span> <span class="mi">196608</span> <span class="n">apache</span> <span class="mi">600</span> <span class="mi">1</span>
<span class="mh">0x00000000</span> <span class="mi">229377</span> <span class="n">apache</span> <span class="mi">600</span> <span class="mi">1</span>
<span class="mh">0x00000000</span> <span class="mi">262146</span> <span class="n">apache</span> <span class="mi">600</span> <span class="mi">1</span>
<span class="mh">0x00000000</span> <span class="mi">294915</span> <span class="n">apache</span> <span class="mi">600</span> <span class="mi">1</span>
<span class="mh">0x00000000</span> <span class="mi">327684</span> <span class="n">apache</span> <span class="mi">600</span> <span class="mi">1</span>
<span class="mh">0x00000000</span> <span class="mi">360453</span> <span class="n">apache</span> <span class="mi">600</span> <span class="mi">1</span>
<span class="mh">0x00000000</span> <span class="mi">393222</span> <span class="n">apache</span> <span class="mi">600</span> <span class="mi">1</span>
<span class="o">------</span><span class="n">Message</span> <span class="n">Queues</span><span class="o">--------</span>
<span class="n">key</span> <span class="n">msqid</span> <span class="n">owner</span> <span class="n">perms</span> <span class="n">used</span><span class="o">-</span><span class="n">bytes</span> <span class="n">messages</span>
</code></pre></div>


<p>输出结果分段显示了系统拥有的共享内存、信号量和消息队列资源。可见，该系统目前尚未使用任何共享内存和消息队列，却分配了一组键值为0（IPC_PRIVATE）的信号量。这些信号量的所有者是apache，因此它们是由httpd服务器程序创建的。其中标识符为393222的信号量正是我们在13.5.5小节讨论的那个用于在httpd各个子进程之间同步epoll_wait使用权的信号量。
，我们可以使用ipcrm命令来删除遗留在系统中的共享资源。</p>
<h3 id="139">13.9 在进程间传递文件描述符<a class="headerlink" href="#139" title="Permanent link">&para;</a></h3>
<p>由于fork调用之后，父进程中打开的文件描述符在子进程中仍然保持打开，所以文件描述符可以很方便地从父进程传递到子进程。需要注意的是，传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。</p>
<p>那么如何把子进程中打开的文件描述符传递给父进程呢？或者更通俗地说，如何在两个不相干的进程之间传递文件描述符呢？在Linux下，我们可以利用UNIX域socket在进程间传递特殊的辅助数据，以实现文件描述符的传递[2]。</p>
<h1 id="14">14章 多线程编程<a class="headerlink" href="#14" title="Permanent link">&para;</a></h1>
<h3 id="141-linux">14.1 Linux 线程概述<a class="headerlink" href="#141-linux" title="Permanent link">&para;</a></h3>
<p>线程是程序中完成一个独立任务的完整执行序列，即一个可调度的实体。根据运行环境和调度者的身份，线程可分为内核线程和用户线程。内核线程，在有的系统上也称为LWP（Light Weight Process，轻量级进程），运行在内核空间，由内核来调度；用户线程运行在用户空间，由线程库来调度。当进程的一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程。可见，内核线程相当于用户线程运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程，其中M≤N。并且在一个系统的所有进程中，M和N的比值都是固定的。按照M:N的取值，线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度（two level scheduler）。</p>
<p>现代Linux上默认使用的线程库是NPTL。用户可以使用如下命令来查看当前系统上所使用的线程库：</p>
<h3 id="142">14.2 创建和结束线程<a class="headerlink" href="#142" title="Permanent link">&para;</a></h3>
<p>创建一个线程的函数是pthread_create。其定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span><span class="o">*</span><span class="kr">thread</span><span class="p">,</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">),</span><span class="kt">void</span><span class="o">*</span><span class="n">arg</span><span class="p">);</span><span class="o">&lt;</span><span class="n">Paste</span><span class="o">&gt;</span>
<span class="c1">// thread参数是新线程的标识符，后续pthread_*函数通过它来引用新线程。其类型pthread_t的定义如下：</span>
<span class="cp">#include</span><span class="cpf">＜bits/pthreadtypes.h＞</span><span class="cp"></span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">pthread_t</span><span class="p">;</span>
</code></pre></div>


<p>线程一旦被创建好，内核就可以调度内核线程来执行start_routine函数指针所指向的函数了。线程函数在结束时最好调用如下函数，以确保安全、干净地退出：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="c1">// pthread_exit函数通过retval参数向线程的回收者传递其退出信息。它执行完之后不会返回到调用者，而且永远不会失败。</span>
<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="n">retval</span><span class="p">);</span>
</code></pre></div>


<p>一个进程中的所有线程都可以调用pthread_join函数来回收其他线程（前提是目标线程是可回收的，见后文），即等待其他线程结束，这类似于回收进程的wait和waitpid系统调用。pthread_join的定义如下：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span><span class="kt">void</span><span class="o">**</span><span class="n">retval</span><span class="p">);</span>
</code></pre></div>


<p>thread参数是目标线程的标识符，retval参数则是目标线程返回的退出信息。该函数会一直阻塞，直到被回收的线程结束为止。该函数成功时返回0，失败则返回错误码。</p>
<p><img alt="" src="../pthread_jon_retval.png" /></p>
<p>有时候我们希望异常终止一个线程，即取消线程，它是通过如下函数实现的：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_cancel</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">);</span>
</code></pre></div>


<p>thread参数是目标线程的标识符。该函数成功时返回0，失败则返回错误码。不过，接收到取消请求的目标线程可以决定是否允许被取消以及如何取消，这分别由如下两个函数完成：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_setcancelstate</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">oldstate</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_setcanceltype</span><span class="p">(</span><span class="kt">int</span> <span class="n">type</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">oldtype</span><span class="p">);</span>
</code></pre></div>


<h3 id="143">14.3 线程属性<a class="headerlink" href="#143" title="Permanent link">&para;</a></h3>
<p>pthread_attr_t结构体定义了一套完整的线程属性，如下所示：
可见，各种线程属性全部包含在一个字符数组中。线程库定义了一系列函数来操作pthread_attr_t类型的变量，以方便我们获取和设置线程属性。这些函数包括：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜bits/pthreadtypes.h＞</span><span class="cp"></span>
<span class="cp">#define__SIZEOF_PTHREAD_ATTR_T 36</span>
<span class="k">typedef</span> <span class="k">union</span>
<span class="p">{</span>
<span class="n">char__size</span><span class="p">[</span><span class="n">__SIZEOF_PTHREAD_ATTR_T</span><span class="p">];</span>
<span class="kt">long</span> <span class="n">int__align</span><span class="p">;</span>
<span class="p">}</span><span class="n">pthread_attr_t</span><span class="p">;</span>

<span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="cm">/*初始化线程属性对象*/</span>
<span class="kt">int</span> <span class="nf">pthread_attr_init</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="cm">/*销毁线程属性对象。被销毁的线程属性对象只有再次初始化之后才能继续使用*/</span>
<span class="kt">int</span> <span class="nf">pthread_attr_destroy</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="cm">/*下面这些函数用于获取和设置线程属性对象的某个属性*/</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getdetachstate</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">detachstate</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setdetachstate</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span> <span class="n">detachstate</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getstackaddr</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">void</span><span class="o">**</span><span class="n">stackaddr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setstackaddr</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">stackaddr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getstacksize</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">size_t</span><span class="o">*</span><span class="n">stacksize</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setstacksize</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">stacksize</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getstack</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">void</span><span class="o">**</span><span class="n">stackaddr</span><span class="p">,</span><span class="kt">size_t</span><span class="o">*</span><span class="n">stacksize</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setstack</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span><span class="n">stackaddr</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">stacksize</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getguardsize</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">__attr</span><span class="p">,</span><span class="kt">size_t</span><span class="o">*</span><span class="n">guardsize</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setguardsize</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">guardsize</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getschedparam</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="k">struct</span> <span class="n">sched_param</span><span class="o">*</span><span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setschedparam</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sched_param</span><span class="o">*</span><span class="n">param</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getschedpolicy</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">policy</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setschedpolicy</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span> <span class="n">policy</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getinheritsched</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">inherit</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setinheritsched</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span> <span class="n">inherit</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_getscope</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">scope</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_attr_setscope</span><span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span> <span class="n">scope</span><span class="p">);</span>
</code></pre></div>


<h3 id="144-posix">14.4 POSIX 信号量<a class="headerlink" href="#144-posix" title="Permanent link">&para;</a></h3>
<p>3种专门用于线程同步的机制：POSIX信号量、互斥量和条件变量。
在Linux上，信号量API有两组。一组是第13章讨论过的System V IPC信号量，另外一组是我们现在要讨论的POSIX信号量。这两组接口很相似，但不保证能互换。由于这两种信号量的语义完全相同，因此我们不再赘述信号量的原理。</p>
<p>POSIX信号量函数的名字都以sem_开头，并不像大多数线程函数那样以pthread_开头。常用的POSIX信号量函数是下面5个：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜semaphore.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span><span class="n">sem</span><span class="p">,</span><span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span><span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span><span class="n">sem</span><span class="p">);</span>
</code></pre></div>


<h3 id="145">14.5 互斥锁<a class="headerlink" href="#145" title="Permanent link">&para;</a></h3>
<p>互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占式的访问，这有点像一个二进制信号量（见13.5.1小节）。当进入关键代码段时，我们需要获得互斥锁并将其加锁，这等价于二进制信号量的P操作；当离开关键代码段时，我们需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程，这等价于二进制信号量的V操作。</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="n">mutex</span><span class="p">,</span><span class="k">const</span> <span class="n">pthread_mutexattr_t</span><span class="o">*</span><span class="n">mutexattr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div>


<p>pthread_mutexattr_t结构体定义了一套完整的互斥锁属性。线程库提供了一系列函数来操作pthread_mutexattr_t类型的变量，以方便我们获取和设置互斥锁属性。这里我们列出其中一些主要的函数：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="cm">/*初始化互斥锁属性对象*/</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_init</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="cm">/*销毁互斥锁属性对象*/</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_destroy</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">);</span>
<span class="cm">/*获取和设置互斥锁的pshared属性*/</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_getpshared</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_mutexattr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">pshared</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_setpshared</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span> <span class="n">pshared</span><span class="p">);</span>
<span class="cm">/*获取和设置互斥锁的type属性*/</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_gettype</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_mutexattr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span><span class="o">*</span><span class="n">type</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_settype</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span><span class="o">*</span><span class="n">attr</span><span class="p">,</span><span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
</code></pre></div>


<h3 id="146">14.6 条件变量<a class="headerlink" href="#146" title="Permanent link">&para;</a></h3>
<p>如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值。条件变量提供了一种线程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程。
条件变量的相关函数主要有如下5个：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_cond_init</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span><span class="n">cond</span><span class="p">,</span><span class="k">const</span> <span class="n">pthread_condattr_t</span><span class="o">*</span><span class="n">cond_attr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_destroy</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span><span class="n">cond</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span><span class="n">cond</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span><span class="n">cond</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span><span class="n">cond</span><span class="p">,</span><span class="n">pthread_mutex_t</span><span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div>


<h3 id="148">14.8 多线程环境<a class="headerlink" href="#148" title="Permanent link">&para;</a></h3>
<h5 id="_1">可重入函数<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h5>
<p>如果一个函数能被多个线程同时调用且不发生竞态条件，则我们称它是线程安全的（thread safe），或者说它是可重入函数。Linux库函数只有一小部分是不可重入的，比如5.1.4小节讨论的inet_ntoa函数，以及5.12.2小节讨论的getservbyname和getservbyport函数。关于Linux上不可重入的库函数的完整列表，请读者参考相关书籍，这里不再赘述。这些库函数之所以不可重入，主要是因为其内部使用了静态变量。不过Linux对很多不可重入的库函数提供了对应的可重入版本，这些可重入版本的函数名是在原函数名尾部加上_r。比如，函数localtime对应的可重入函数是localtime_r。在多线程程序中调用库函数，一定要使用其可重入版本，否则可能导致预想不到的结果。</p>
<h5 id="_2">线程和进程<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h5>
<p>思考这样一个问题：如果一个多线程程序的某个线程调用了fork函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？答案是“否”，正如我们期望的那样。子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已经被加锁的互斥锁在子进程中也是被锁住的。</p>
<h5 id="_3">线程和信号<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h5>
<p>每个线程都可以独立地设置信号掩码。我们在10.3.2小节讨论过设置进程信号掩码的函数sigprocmask，但在多线程环境下我们应该使用如下所示的pthread版本的sigprocmask函数来设置线程信号掩码：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜pthread.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜signal.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_sigmask</span><span class="p">(</span><span class="kt">int</span> <span class="n">how</span><span class="p">,</span><span class="k">const</span> <span class="kt">sigset_t</span><span class="o">*</span><span class="n">newmask</span><span class="p">,</span><span class="kt">sigset_t</span><span class="o">*</span><span class="n">oldmask</span><span class="p">);</span>
</code></pre></div>


<p>最后，pthread还提供了下面的方法，使得我们可以明确地将一个信号发送给指定的线程：</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜signal.h＞</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_kill</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span><span class="kt">int</span> <span class="n">sig</span><span class="p">);</span>
</code></pre></div>


<h1 id="15">15章 进程池和线程池<a class="headerlink" href="#15" title="Permanent link">&para;</a></h1>
<h3 id="151">15.1 进程池和线程池概述<a class="headerlink" href="#151" title="Permanent link">&para;</a></h3>
<p>进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即它们没有打开不必要的文件描述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父进程复制得到）。</p>
<p><img alt="" src="../process_pool.png" /></p>
<h3 id="152">15.2 处理多客户<a class="headerlink" href="#152" title="Permanent link">&para;</a></h3>
<p>如果客户任务是存在上下文关系的，则最好一直用同一个子进程来为之服务，否则实现起来将比较麻烦，因为我们不得不在各子进程之间传递上下文数据。在9.3.4小节中，我们讨论了epoll的EPOLLONESHOT事件，这一事件能够确保一个客户连接在整个生命周期中仅被一个线程处理。</p>
<h3 id="153">15.3　半同步/半异步进程池实现<a class="headerlink" href="#153" title="Permanent link">&para;</a></h3>
<p>为了避免在父、子进程之间传递文件描述符，我们将接受新连接的操作放到子进程中。很显然，对于这种模式而言，一个客户连接上的所有任务始终是由一个子进程来处理的。</p>
<p>后面都是代码实现，具体参考原书</p>
<h1 id="16">第16章　服务器调制、调试和测试<a class="headerlink" href="#16" title="Permanent link">&para;</a></h1>
<h3 id="161">16.1　最大文件描述符数<a class="headerlink" href="#161" title="Permanent link">&para;</a></h3>
<p>文件描述符是服务器程序的宝贵资源，几乎所有的系统调用都是和文件描述符打交道。系统分配给应用程序的文件描述符数量是有限制的，所以我们必须总是关闭那些已经不再使用的文件描述符，以释放它们占用的资源。比如作为守护进程运行的服务器程序就应该总是关闭标准输入、标准输出和标准错误这3个文件描述符。
Linux对应用程序能打开的最大文件描述符数量有两个层次的限制：用户级限制和系统级限制。用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数；系统级的限制是指所有用户总共能打开的文件描述符数。</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># 下面这个命令是最常用的查看用户级文件描述符数限制的方法：</span>
<span class="nb">ulimit</span> -n
</code></pre></div>


<p>为永久修改用户级文件描述符数限制，可以在/etc/security/limits.conf文件中加入如下两项：</p>
<div class="codehilite"><pre><span></span><code>*hard nofile max-file-number
*hard nofile max-file-number
*soft nofile max-file-number
</code></pre></div>


<p>要永久更改系统级文件描述符数限制，则需要在/etc/sysctl.conf文件中添加如下一项：</p>
<div class="codehilite"><pre><span></span><code>fs.file-max<span class="o">=</span>max-file-number <span class="c1"># 然后通过执行sysctl-p命令使更改生效。</span>
</code></pre></div>


<h3 id="162">16.2　调整内核参数<a class="headerlink" href="#162" title="Permanent link">&para;</a></h3>
<h5 id="1621-procsysfs">16.2.1　/proc/sys/fs目录下的部分文件<a class="headerlink" href="#1621-procsysfs" title="Permanent link">&para;</a></h5>
<p>❑/proc/sys/fs/file-max，系统级文件描述符数限制。
❑/proc/sys/fs/epoll/max_user_watches，一个用户能够往epoll内核事件表中注册的事件的总量。</p>
<h5 id="1622-procsysnet">16.2.2　/proc/sys/net目录下的部分文件<a class="headerlink" href="#1622-procsysnet" title="Permanent link">&para;</a></h5>
<p>❑/proc/sys/net/core/somaxconn，指定listen监听队列里，能够建立完整连接从而进入ESTABLISHED状态的socket的最大数目。</p>
<p>❑/proc/sys/net/ipv4/tcp_max_syn_backlog，指定listen监听队列里，能够转移至ESTAB-LISHED或者SYN_RCVD状态的socket的最大数目。o</p>
<p>❑/proc/sys/net/ipv4/tcp_wmem，它包含3个值，分别指定一个socket的TCP写缓冲区的最小值、默认值和最大值。</p>
<p>❑/proc/sys/net/ipv4/tcp_rmem，它包含3个值，分别指定一个socket的TCP读缓冲区的最小值、默认值和最大值。在代码清单3-6中，我们正是通过修改这个参数来改变接收通告窗口大小的。</p>
<p>❑/proc/sys/net/ipv4/tcp_syncookies，指定是否打开TCP同步标签（syncookie）。同步标签通过启动cookie来防止一个监听socket因不停地重复接收来自同一个地址的连接请求（同步报文段），而导致listen监听队列溢出（所谓的SYN风暴）。<Paste></p>
<h3 id="gdb">gdb 调试<a class="headerlink" href="#gdb" title="Permanent link">&para;</a></h3>
<h5 id="1631-gdb">16.3.1　用gdb调试多进程程序<a class="headerlink" href="#1631-gdb" title="Permanent link">&para;</a></h5>
<p>如果一个进程通过fork系统调用创建了子进程，gdb会继续调试原来的进程，子进程则正常运行。那么该如何调试子进程呢？常用的方法有如下两种。</p>
<p>1.单独调试子进程</p>
<p>子进程从本质上说也是一个进程，因此我们可以用通用的gdb调试方法来调试它。举例来说，如果要调试代码清单15-2描述的CGI进程池服务器的某一个子进程，则我们可以先运行服务器，然后找到目标子进程的PID，再将其附加（attach）到gdb调试器上，具体操作如代码清单16-1所示。</p>
<p>2.使用调试器选项follow-fork-mode</p>
<p>gdb调试器的选项follow-fork-mode允许我们选择程序在执行fork系统调用后是继续调试父进程还是调试子进程。其用法如下：</p>
<p><code>(gdb)set follow-fork-mode mode</code></p>
<h5 id="1632-gdb">16.3.2　用gdb调试多线程程序<a class="headerlink" href="#1632-gdb" title="Permanent link">&para;</a></h5>
<p>gdb有一组命令可辅助多线程程序的调试。下面我们仅列举其中常用的一些：</p>
<p>❑info threads，显示当前可调试的所有线程。gdb会为每个线程分配一个ID，我们可以使用这个ID来操作对应的线程。ID前面有“*”号的线程是当前被调试的线程。</p>
<p>❑thread ID，调试目标ID指定的线程。</p>
<p>❑set scheduler-locking[off|on|step]。调试多线程程序时，默认除了被调试的线程在执行外，其他线程也在继续执行，但有的时候我们希望只让被调试的线程运行。这可以通过这个命令来实现。该命令设置scheduler-locking的值：off表示不锁定任何线程，即所有线程都可以继续执行，这是默认值；on表示只有当前被调试的线程会继续执行；step表示在单步执行的时候，只有当前线程会执行。</p>
<h3 id="164">16.4 压力测试<a class="headerlink" href="#164" title="Permanent link">&para;</a></h3>
<p>压力测试程序有很多种实现方式，比如I/O复用方式，多线程、多进程并发编程方式，以及这些方式的结合使用。不过，单纯的I/O复用方式的施压程度是最高的，因为线程和进程的调度本身也是要占用一定CPU时间的。我们将使用epoll来实现一个通用的服务器压力测试程序，</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span><span class="cpf">＜stdlib.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜stdio.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜assert.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜unistd.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/types.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/epoll.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜fcntl.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜sys/socket.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜netinet/in.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜arpa/inet.h＞</span><span class="cp"></span>
<span class="cp">#include</span><span class="cpf">＜string.h＞</span><span class="cp"></span>
<span class="cm">/*每个客户连接不停地向服务器发送这个请求*/</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">request</span><span class="o">=</span><span class="s">&quot;GET http://localhost/index.html HTTP/1.1</span><span class="se">\r\n</span><span class="s">Connection:keep-alive</span><span class="se">\r\n\r\n</span><span class="s">xxxxxxxxxxxx&quot;</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">setnonblocking</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">old_option</span><span class="o">=</span><span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">F_GETFL</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">new_option</span><span class="o">=</span><span class="n">old_option</span><span class="o">|</span><span class="n">O_NONBLOCK</span><span class="p">;</span>
    <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="n">F_SETFL</span><span class="p">,</span><span class="n">new_option</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">old_option</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">addfd</span><span class="p">(</span><span class="kt">int</span> <span class="n">epoll_fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
    <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="o">=</span><span class="n">fd</span><span class="p">;</span>
    <span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="o">=</span><span class="n">EPOLLOUT</span><span class="o">|</span><span class="n">EPOLLET</span><span class="o">|</span><span class="n">EPOLLERR</span><span class="p">;</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">EPOLL_CTL_ADD</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="err">＆</span><span class="n">event</span><span class="p">);</span>
    <span class="n">setnonblocking</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*向服务器写入len字节的数据*/</span>
<span class="kt">bool</span> <span class="nf">write_nbytes</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">bytes_write</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;write out%d bytes to socket%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">len</span><span class="p">,</span><span class="n">sockfd</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">bytes_write</span><span class="o">=</span><span class="n">send</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="n">len</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">bytes_write</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">bytes_write</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">len</span><span class="o">-=</span><span class="n">bytes_write</span><span class="p">;</span>
        <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="o">+</span><span class="n">bytes_write</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">len</span><span class="err">＜</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*从服务器读取数据*/</span>
<span class="kt">bool</span> <span class="nf">read_once</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">bytes_read</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="sc">&#39;\0&#39;</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
    <span class="n">bytes_read</span><span class="o">=</span><span class="n">recv</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="n">len</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">bytes_read</span><span class="o">==-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">bytes_read</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;read in%d bytes from socket%d with content:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">bytes_read</span><span class="p">,</span><span class="n">sockfd</span><span class="p">,</span><span class="n">buffer</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*向服务器发起num个TCP连接，我们可以通过改变num来调整测试压力*/</span>
<span class="kt">void</span> <span class="nf">start_conn</span><span class="p">(</span><span class="kt">int</span> <span class="n">epoll_fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">num</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">ip</span><span class="p">,</span><span class="kt">int</span> <span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">address</span><span class="p">;</span>
    <span class="n">bzero</span><span class="p">(</span><span class="err">＆</span><span class="n">address</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">));</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_family</span><span class="o">=</span><span class="n">AF_INET</span><span class="p">;</span>
    <span class="n">inet_pton</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span><span class="n">ip</span><span class="p">,</span><span class="err">＆</span><span class="n">address</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">);</span>
    <span class="n">address</span><span class="p">.</span><span class="n">sin_port</span><span class="o">=</span><span class="n">htons</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="err">＜</span><span class="n">num</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">sockfd</span><span class="o">=</span><span class="n">socket</span><span class="p">(</span><span class="n">PF_INET</span><span class="p">,</span><span class="n">SOCK_STREAM</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;create 1 sock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sockfd</span><span class="err">＜</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="err">＆</span><span class="n">address</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">address</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;build connection%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
            <span class="n">addfd</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">sockfd</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">close_conn</span><span class="p">(</span><span class="kt">int</span> <span class="n">epoll_fd</span><span class="p">,</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">EPOLL_CTL_DEL</span><span class="p">,</span><span class="n">sockfd</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">sockfd</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">argc</span><span class="o">==</span><span class="mi">4</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">epoll_fd</span><span class="o">=</span><span class="n">epoll_create</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">start_conn</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
    <span class="n">epoll_event</span> <span class="n">events</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">fds</span><span class="o">=</span><span class="n">epoll_wait</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">events</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="mi">2000</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="err">＜</span><span class="n">fds</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">sockfd</span><span class="o">=</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="err">＆</span><span class="n">EPOLLIN</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">read_once</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="n">buffer</span><span class="p">,</span><span class="mi">2048</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">close_conn</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">sockfd</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
                <span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="o">=</span><span class="n">EPOLLOUT</span><span class="o">|</span><span class="n">EPOLLET</span><span class="o">|</span><span class="n">EPOLLERR</span><span class="p">;</span>
                <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="o">=</span><span class="n">sockfd</span><span class="p">;</span>
                <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span><span class="n">sockfd</span><span class="p">,</span><span class="err">＆</span><span class="n">event</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="err">＆</span><span class="n">EPOLLOUT</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">write_nbytes</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span><span class="n">request</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">request</span><span class="p">)))</span>
                <span class="p">{</span>
                    <span class="n">close_conn</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">sockfd</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">event</span><span class="p">;</span>
                <span class="n">event</span><span class="p">.</span><span class="n">events</span><span class="o">=</span><span class="n">EPOLLIN</span><span class="o">|</span><span class="n">EPOLLET</span><span class="o">|</span><span class="n">EPOLLERR</span><span class="p">;</span>
                <span class="n">event</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="o">=</span><span class="n">sockfd</span><span class="p">;</span>
                <span class="n">epoll_ctl</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">EPOLL_CTL_MOD</span><span class="p">,</span><span class="n">sockfd</span><span class="p">,</span><span class="err">＆</span><span class="n">event</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">events</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">events</span><span class="err">＆</span><span class="n">EPOLLERR</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">close_conn</span><span class="p">(</span><span class="n">epoll_fd</span><span class="p">,</span><span class="n">sockfd</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="17">17 系统检测工具<a class="headerlink" href="#17" title="Permanent link">&para;</a></h1>
<ul>
<li>tcpdump: 网络抓包工具 (Wireshark)</li>
<li>lsof（list open file）:是一个列出当前系统打开的文件描述符的工具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者我们感兴趣的文件描述符被哪些进程打开了。</li>
<li>nc: nc（netcat）命令短小精干、功能强大，有着“瑞士军刀”的美誉。它主要被用来快速构建网络连接。我们可以让它以服务器方式运行，监听某个端口并接收客户连接，因此它可用来调试客户端程序。我们也可以使之以客户端方式运行，向服务器发起连接并收发数据，因此它可以用来调试服务器程序，此时它有点像telnet程序。</li>
<li>strace: 测试服务器性能的重要工具。它跟踪程序运行过程中执行的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号名输出到标准输出或者指定的文件。</li>
<li>netstat: 是一个功能很强大的网络信息统计工具。它可以打印本地网卡接口上的全部连接、路由表信息、网卡接口信息等。对本书而言，我们主要利用的是上述功能中的第一个，即显示TCP连接及其状态信息。毕竟，要获得路由表信息和网卡接口信息，我们可以使用输出内容更丰富的route和ifconfig命令。</li>
<li>vmstat:是 virtual memory statistics的缩写，它能实时输出系统的各种资源的使用情况，比如进程信息、内存使用、CPU使用率以及I/O使用情况。不过，我们可以使用iostat命令获得磁盘使用情况的更多信息，也可以使用mpstat获得CPU使用情况的更多信息。vmstat命令主要用于查看系统内存的使用情况。</li>
<li>ifstat: 是interface statistics的缩写，它是一个简单的网络流量监测工具。</li>
<li>mpstat: 是multi-processor statistics的缩写，它能实时监测多处理器系统上每个CPU的使用情况。mpstat命令和iostat命令通常都集成在包sysstat中，安装sysstat即可获得这两个命令。</li>
</ul>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../../../network/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/" title="TCP IP详解卷一" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                TCP IP详解卷一
              </div>
            </div>
          </a>
        
        
          <a href="../../unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/" title="unix编程艺术" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                unix编程艺术
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../../assets/javascripts/bundle.5f27aba8.min.js"></script><script id="__lang" type="application/json">{"search.result.other": "# matching documents", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "clipboard.copied": "Copied to clipboard", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.config.pipeline": "trimmer, stopWordFilter", "search.result.placeholder": "Type to start searching", "search.config.separator": "[\\s\\-]+"}</script>
      
      <script>
        app = initialize({
          base: "../../..",
          features: ["instant"],
          search: Object.assign({
            worker: "../../../assets/javascripts/worker/search.27c6a5e6.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      
    
  </body>
</html>