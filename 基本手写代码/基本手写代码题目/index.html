<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>基本手写代码题目 - ZWiley的读书笔记</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u57fa\u672c\u624b\u5199\u4ee3\u7801\u9898\u76ee";
    var mkdocs_page_input_path = "\u57fa\u672c\u624b\u5199\u4ee3\u7801\\\u57fa\u672c\u624b\u5199\u4ee3\u7801\u9898\u76ee.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> ZWiley的读书笔记</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">简介</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">C++</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E7%BC%96%E8%AF%91%E5%BA%95%E5%B1%82/">C++编译底层</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">C++基础知识</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88_%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6_%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2_RTTI/">C++智能指针</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/C%2B%2B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">C++面向对象</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/STL/">C++ STL</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">计算机基础知识</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/">海量数据处理</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">基本手写代码</span></p>
                <ul class="current">
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">基本手写代码题目</a>
    <ul class="current">
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">项目基础知识</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/">Linux系统编程及基本命令</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/MySQL/">MySQL</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Redis/">Redis</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Socket%E7%BC%96%E7%A8%8B/">Socket编程</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">代码</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/work_with_legacy_code/">Work with legacy code</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/">代码大全</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%AA%E6%9D%A5/">代码的未来</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E5%9F%BA%E6%9C%AC%E5%8A%9F/">基本功</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E6%95%8F%E6%8D%B7%E6%8A%80%E8%83%BD%E4%BF%AE%E7%82%BC/">敏捷技能修炼</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%8497%E4%BB%B6%E4%BA%8B/">程序员应该知道的97件事</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E7%BC%96%E5%86%99%E5%8F%AF%E8%AF%BB%E4%BB%A3%E7%A0%81%E7%9A%84%E8%89%BA%E6%9C%AF/">编写可读代码的艺术</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E7%BC%96%E7%A8%8B%E5%8C%A0%E8%89%BA/">编程匠艺</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">领域驱动设计</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../code/codelife_%E4%B8%8D%E6%AD%A2%E4%BB%A3%E7%A0%81/">codelife_不止代码</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">调试技术</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../debug/%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/book/">软件调试修炼之道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../debug/Effective_Debugging/">Effective Debugging</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">数据库</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/getting_started_with_impala/">Getting started with impala</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mysql必知必会</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/">mysql性能调优与架构实践</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/Mysql%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">Mysql技术内幕InnoDB存储引擎</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/redis%E5%AE%9E%E6%88%98/">Redis实战</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/redis%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/book/">Redis深度历险核心原理和应用实践</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">redis设计与实现</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/%E4%B8%83%E5%91%A8%E4%B8%83%E6%95%B0%E6%8D%AE%E5%BA%93/">七周七数据库</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAmysql/">深入浅出mysql</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../database/%E9%AB%98%E6%80%A7%E8%83%BDmysql%E7%AC%AC%E4%B8%89%E7%89%88/">高性能mysql第三版</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">前端</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../frontend/CSS_The_Missing_Manual/">CSS_The_Missing_Manual</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../frontend/reactjs_%E5%B0%8F%E4%B9%A6/">reactjs小书</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../frontend/es6%E6%A0%87%E5%87%86%E5%85%A5%E9%97%A8/">ES6标准入门</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../frontend/jquery_pocket_reference/">jquery_pocket_reference</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../frontend/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3bootstrap/">深入理解bootstrap</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">golang</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/1_the_go_programming_lauguage/">1 The Go Programming Language</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/2_the_go_programming_lauguage/">2 The Go Programming Language</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/3_the_go_programming_lauguage/">3 The Go Programming Language</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/build-web-application-with-golang/">Build Web Application With Golang</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/go101/book/">Go101</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/network-programming-with-go/book/">Network Programming with go</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/building-microservices-with-go/book/">Building Microservices With Go</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/building_restful_web_services_with_go/book/">Building Restful Web Services with Go</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/concurrency-in-go/concurrency_in_go/">Concurrency In Go</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/go_in_action%28go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%29/">Go In Action(Go 实战)</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%AF%AD%E8%A8%80%E8%AF%A6%E8%A7%A3/">Go学习笔记语言详解</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/">Go学习笔记源码剖析</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/go%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/">go语言编程</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/the_way_to_go/book/">go book</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/advanced-go-programming-book/advanced-go-programming/">advanced-go-programming</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../golang/go-build-web-applications/module1/go-build-web-applications/go-build-web-applications/">go-build-web-applications</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">java</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../java/java-basic-introduction/">java basic introduction</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">网络</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../network/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/tcp_ip%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80/">TCP IP详解卷一</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">python</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../python/fluent_python/">Fluent Python</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../python/Python_Microservices_Development/">Python Microservices Development</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../python/high_performance_python/">High Performance Python</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../python/python_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">Python网络编程</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">unix/linux</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../unix_linux/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">Linux高性能服务器编程</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../unix_linux/unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/">unix编程艺术</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../unix_linux/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%8D%B7%E4%B8%80/">unix网络编程卷一</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../unix_linux/unix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/">unix编程艺术</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">分布式</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%88%86%E5%B8%83%E5%BC%8F/Kafka%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/">Kafka 权威指南</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/">分布式框架原理与应用</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%88%86%E5%B8%83%E5%BC%8F/%E5%A4%A7%E8%A7%84%E6%A8%A1%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/">大规模分布式存储系统</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B7%B1%E5%85%A5%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5/">深入分布式缓存从原理到实践</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">搜索引擎</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/Elasticsearch%E5%AE%9E%E6%88%98/book/">Elasticsearch实战</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">容器</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../devops/%E7%8E%A9%E8%BD%ACKubernets-CloudMan/">玩转Kubernets</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../devops/%E7%AC%AC%E4%B8%80%E6%9C%ACdocker%E4%B9%A6/">第一本docker书</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">开发工具</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/practical_vim/practical_vim/">Practical Vim</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/vim8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/vim8%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98/">Vim8文本处理实战</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/learn_vim_the_hard_way/">Learn vim scrpt the hard way</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/pro_git/">Pro Git</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Mastering_vim/">Mastering Vim</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/mastering_vim_quickly/">Mastering Vim Quickly</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">思维</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E4%B8%93%E6%B3%A8%E5%8A%9B_%E5%8C%96%E7%B9%81%E4%B8%BA%E7%AE%80%E7%9A%84%E6%83%8A%E4%BA%BA%E5%8A%9B%E9%87%8F/">专注力</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B2%BE%E8%8B%B1%E8%BF%99%E6%A0%B7%E7%94%A8%E8%84%91%E4%B8%8D%E4%BC%9A%E7%B4%AF/">为什么精英这样用脑不会累</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0/">刻意练习</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%A6%82%E4%BD%95%E6%83%B3%E5%88%B0%E5%8F%88%E5%81%9A%E5%88%B0/">如何想到又做到</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%81%93/">学习之道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%AD%A6%E4%B9%A0%E5%8A%9B/">学习力</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7/">批判性思维工具</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BF%AE%E7%82%BC%28%E5%BC%80%E5%8F%91%E8%AE%A4%E7%9F%A5%E6%BD%9C%E8%83%BD%E7%9A%84%E4%B9%9D%E5%A0%82%E8%AF%BE%29/">程序员的思维修炼</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E8%AE%A4%E7%9F%A5%E5%A4%A9%E6%80%A7/">认知天性</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E8%B6%85%E6%95%88%E7%8E%87%E6%89%8B%E5%86%8C/">超效率手册</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%AE%B0%E5%BF%86/">如何高效记忆</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E7%A7%91%E5%AD%A6%E5%AD%A6%E4%B9%A0/">科学学习</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF/">高效程序员的45个习惯</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">源码</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB_sourcecode/">源码阅读</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">网站架构微服务</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/microservices_patterns_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/book/">微服务架构设计模式</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%9E%B6%E6%9E%84/">从0开始学架构</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/web_scalavility_for_startup_engineers/">web scalavility for startup engineers</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/design_data_instensive_application/">design_data_instensive_application</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/clean_architecture/">clean_architecture</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/">微服务设计</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/2_design_data_instensive_application/">2_design_data_instensive_application</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/3_design_data_instensive_application/">3_design_data_instensive_application</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">软件工程/项目管理</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/">人月神话</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BB%A3%E7%A0%81%E4%B9%8B%E6%AE%87/">代码之殇</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E8%A7%A3%E6%9E%90%E6%9E%81%E9%99%90%E7%BC%96%E7%A8%8B-%E6%8B%A5%E6%8A%B1%E5%8F%98%E5%8C%96/">解析极限编程</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93/">项目管理修炼之道</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B_%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E4%BF%AE%E6%94%B9%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%89%BA%E6%9C%AF/">修改软件的艺术</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">运维</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%BF%90%E7%BB%B4/linux%E9%9B%86%E7%BE%A4%E5%92%8C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/">linux集群和自动化运维</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E8%BF%90%E7%BB%B4/python%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/">python自动化运维</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">金融理财</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/%E5%AE%9A%E6%8A%95%E5%8D%81%E5%B9%B4/">定投十年</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E9%87%91%E8%9E%8D%E7%90%86%E8%B4%A2/%E7%A9%B7%E6%9F%A5%E7%90%86%E5%AE%9D%E5%85%B8/">穷查理宝典</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">写作</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%86%99%E4%BD%9C/%E5%88%B7%E5%B1%8F%E6%96%87%E6%A1%88%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/">刷屏文案写作技巧</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">互联网</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E4%BA%92%E8%81%94%E7%BD%91/%E6%88%91%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E6%96%B9%E6%B3%95%E8%AE%BA-%E5%91%A8%E9%B8%BF%E7%A5%8E/">我的互联网方法论-周鸿祎</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E4%BA%92%E8%81%94%E7%BD%91/%E7%94%A8%E6%88%B7%E6%80%9D%E7%BB%B4/">用户思维</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">区块链</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97%28blockchain_guide%29/">区块链技术指南</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">技术演讲</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../lecture/Gopher/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9%E7%9A%84go%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E6%88%98/note/">哔哩哔哩的go微服务实战</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../lecture/Gopher/Go_Error/go%E4%B8%9A%E5%8A%A1%E5%9F%BA%E7%A1%80%E5%BA%93%E4%B9%8BError%26Context/">go业务基础库之Error&Context</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../lecture/Gopher/Go%E5%90%8C%E6%AD%A5%E5%92%8C%E5%B9%B6%E5%8F%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/note/">Go同步和并发设计模式</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../lecture/%E6%8A%80%E6%9C%AF%E6%BC%94%E8%AE%B2/%E5%B7%A6%E8%80%B3%E6%9C%B5%E8%80%97%E5%AD%90-%E6%88%91%E8%BF%99%E6%8A%80%E6%9C%AF%E4%BA%8C%E5%8D%81%E5%B9%B4/">左耳朵耗子-我这技术二十年</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">职场</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/give_and_take/">give and take</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/the_effective_engineer/">the_effective_engineer</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E5%85%89%E9%80%9F%E6%88%90%E9%95%BF/">光速成长</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E5%90%91%E4%B8%8A%E7%AE%A1%E7%90%86/">向上管理</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E6%88%90%E5%8A%9F%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9B%AE%E6%A0%87/">成功动机与目标</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/">番茄工作法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E8%81%86%E5%90%AC%E6%B2%9F%E9%80%9A%E5%AD%A6/">聆听沟通学</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E7%9F%A5%E4%B9%8E%E8%81%8C%E4%BA%BA%E8%A7%89%E9%86%92/">知乎职人觉醒</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E7%9F%A5%E8%AF%86%E5%8F%98%E7%8E%B0/">知识变现</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E8%81%86%E5%90%AC%E6%B2%9F%E9%80%9A%E5%AD%A6/">聆听沟通学</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E8%81%8C%E5%9C%BA%E5%8A%A8%E7%89%A9%E8%BF%9B%E5%8C%96%E6%89%8B%E5%86%8C/">职场动物进化手册</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E8%81%8C%E5%9C%BA%E8%A7%A3%E9%87%8A%E7%B3%BB/">职场解释系</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E8%AF%B7%E5%81%9C%E6%AD%A2%E6%97%A0%E6%95%88%E5%8A%AA%E5%8A%9B/">请停止无效努力</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E8%BD%AF%E6%8A%80%E8%83%BD/">软技能</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E9%AB%98%E6%95%8815%E6%B3%95%E5%88%99/">高效15法则</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E9%AB%98%E6%95%88%E6%B8%85%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%B3%95/">高效清单工作法</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../career/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/">程序员的自我修养</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">心理学</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E7%AB%A5%E5%B9%B4%E7%9A%84%E9%94%99%E5%90%97/">一切都是童年的错吗</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/">亲密关系</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E6%83%85%E5%95%86/">情商</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E9%80%86%E5%95%86/">逆商</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E6%8B%96%E5%BB%B6%E5%BF%83%E7%90%86%E5%AD%A6/">拖延心理学</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E7%A7%AF%E6%9E%81%E5%BF%83%E7%90%86%E5%AD%A6/">积极心理学</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B/">自控力</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B-%E5%AE%9E%E6%93%8D%E7%AF%87/">自控力-实操篇</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E8%87%AA%E6%8E%A7%E5%8A%9B-%E5%92%8C%E5%8E%8B%E5%8A%9B%E5%81%9A%E6%9C%8B%E5%8F%8B/">自控力:和压力做朋友</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E6%B4%BB%E5%87%BA%E6%9C%80%E4%B9%90%E8%A7%82%E7%9A%84%E8%87%AA%E5%B7%B1/">活出最乐观的自己</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E6%94%B9%E5%8F%98%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%8440%E9%A1%B9%E7%A0%94%E7%A9%B6/">改变心理学的40项研究</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E8%B6%85%E8%B6%8A%E8%87%AA%E5%8D%91/">超越自卑</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../psychology/%E5%8F%8D%E8%84%86%E5%BC%B1/">反脆弱</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">创业</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../../startup/hello_startup/">Hello Startup</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../startup/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%85%AC%E5%BC%80%E8%AF%BE-%E5%A6%82%E4%BD%95%E5%88%9B%E4%B8%9A/">斯坦福公开课如何创业</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../../startup/%E8%BF%90%E8%90%A5%E5%85%B6%E5%AE%9E%E5%BE%88%E7%AE%80%E5%8D%95/">运营其实很简单</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">ZWiley的读书笔记</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>基本手写代码 &raquo;</li>
        
      
    
    <li>基本手写代码题目</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/zwiley/mybook/edit/master/docs/基本手写代码/基本手写代码题目.md"
          class="icon icon-github"> Edit on GitHub</a>
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="_1">插入排序<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="c1">//插入排序，平均情况O(n^2),最好O(n)，最坏O(n^2),，空间复杂度O(1)，稳定</span>

<span class="cm">/*</span>
<span class="cm">插入排序思想</span>
<span class="cm">a[5] = {2,1,3,4,5}</span>
<span class="cm">外层循环：a[0]不用管，默认有序，从a[1]开始往后循环</span>
<span class="cm">内层循环：将需要移动的元素a[1]存入临时变量</span>
<span class="cm">        遍历a[1]前面的元素，与当前a[1]进行比较，若遍历的当前元素大于a[1]，元素后移a[j] = a[j - 1]</span>
<span class="cm">        直到数据元素小于等于临时变量</span>
<span class="cm">        移动完后，将当前位置赋值为临时变量</span>
<span class="cm">*/</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//频繁交换</span>
<span class="kt">void</span> <span class="nf">insertSortBad</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">){</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//将频繁交换转换为赋值</span>
<span class="kt">void</span> <span class="nf">insertSort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="c1">//临时变量,存放需要移动的元素</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">){</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span> <span class="p">};</span>
    <span class="n">insertSortBad</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_2">二分查找<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="cm">/**************************************************************************</span>
<span class="cm">**  二分查找法</span>
<span class="cm">**  在有序数组中查找target，查找到返回index，否则返回-1</span>
<span class="cm">*************************************************************************/</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">){</span>

    <span class="c1">//在[l,r]中查找target</span>
    <span class="c1">//包含右边界</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">res</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">){</span>
        <span class="c1">//int mid = (l + r) / 2;</span>
        <span class="c1">//防止溢出</span>
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">){</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//在[l,mid-1]中查找target</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">//在[mid+1,r]中查找target</span>
        <span class="k">else</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_3">快速排序<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="c1">//快速排序思想：</span>
<span class="c1">//选出一个哨兵，通过一趟排序将待排序列分割成两部分</span>
<span class="c1">//其中一部分小于哨兵值，另外一部分大于哨兵值</span>
<span class="c1">//然后再对两部分分别进行上述操作，直到排序完成</span>


<span class="c1">//解释时间复杂度为nlogn</span>
<span class="c1">//分治算法，每次选出哨兵，将待排序列分成两部分，一直分下去，直到只有一个元素，平均分开，相当于n个结点的二叉树，共有logn层，递归深度为logn</span>
<span class="c1">//每一层都需要对当前分组的元素排序，问题规模大概为n，第一层遍历n个元素，第二层遍历n-1个...直到最后一层为一个</span>
<span class="c1">//nlogn</span>

<span class="c1">//解释空间复杂度O(logn)~O(n)</span>
<span class="c1">//主要是递归造成的栈空间的使用</span>
<span class="c1">//最好情况递归树深度为logn，最坏情况为n</span>

<span class="c1">//快排的最差情况什么时候发生？</span>
<span class="c1">//1. 已排序</span>
<span class="c1">//2. 数值全部相等（1的特殊情况）</span>
<span class="c1">//在上面的情况下选择的标定元素一直为第一个，则时间复杂度变为O(n^2)</span>

<span class="c1">//快速排序，平均情况O(nlogn),最好O(nlogn)，最坏O(n^2)（选择标定元素有关），空间复杂度O(logn)~O(n)，不稳定</span>

<span class="cm">/**************************************************************************</span>
<span class="cm">**  要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;</span>
<span class="cm">**  要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;</span>
<span class="cm">**  要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;</span>
<span class="cm">**  通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。</span>
<span class="cm">**  要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。</span>
<span class="cm">**  要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</span>
<span class="cm">*************************************************************************/</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//双路快排，尽量写这种</span>
<span class="c1">//begin,begin+1...i...j...end</span>
<span class="kt">int</span> <span class="nf">partition2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
    <span class="c1">//产生start和end之间的随机数</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>

    <span class="c1">//将选中的数字交换到start位置</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>

    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>

    <span class="c1">//选择的pivot为start位置</span>
    <span class="c1">//data[start+1, i) &lt;= pivot   i-1 为小于v的最后一个元素，i为当前左边访问的元素</span>
    <span class="c1">//data(j, end] &gt;= pivot  j+1 为大于v的第一个元素，j为当前右边访问的元素</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">)</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

        <span class="c1">//下面这两行，swap交换之后，双方需要移动，否则会增加一次无用的比较</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">j</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//最后j停止在&lt;= v的最后一个位置， i停止在&gt;=pivot的第一个位置，pivot与j进行交换</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swapOffer</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//单路随机快排</span>
<span class="c1">//begin,begin+1...small,small+1...end</span>
<span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
    <span class="c1">//产生start和end之间的随机数</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>

    <span class="c1">//将选中的数字交换到start位置</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>

    <span class="c1">//选择的pivot为start位置</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>

    <span class="c1">//我们要达到这样的效果</span>
    <span class="c1">//data[start+1, small] &lt; v   small为小于pivot的最后一个元素</span>
    <span class="c1">//data[small+1, i - 1] &gt;= v   small+1为大于等于pivot的第一个元素</span>

    <span class="c1">//注意small的取值,small是为了标识小于</span>
    <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">){</span>
            <span class="c1">//若当前的元素小于pivot，需要将该元素放到data[start+1, small]中紧挨着small位置</span>
            <span class="c1">//将small+1和i进行交换，并将small的长度加长</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="o">++</span><span class="n">small</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//最后将start放在应该的位置，即small和small+1之间，因为左侧全是小于pivot的，因此将small和pivot交换</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">small</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">small</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">quickSortOffer</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">partition2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>  <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="n">quickSortOffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>  <span class="n">start</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">quickSortOffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>
    <span class="n">quickSortOffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>  <span class="c1">//0表示从数组0位置开始，到4位置排序 </span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_4">归并排序<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="c1">//快速排序思想：</span>
<span class="c1">//选出一个哨兵，通过一趟排序将待排序列分割成两部分</span>
<span class="c1">//其中一部分小于哨兵值，另外一部分大于哨兵值</span>
<span class="c1">//然后再对两部分分别进行上述操作，直到排序完成</span>


<span class="c1">//解释时间复杂度为nlogn</span>
<span class="c1">//分治算法，每次选出哨兵，将待排序列分成两部分，一直分下去，直到只有一个元素，平均分开，相当于n个结点的二叉树，共有logn层，递归深度为logn</span>
<span class="c1">//每一层都需要对当前分组的元素排序，问题规模大概为n，第一层遍历n个元素，第二层遍历n-1个...直到最后一层为一个</span>
<span class="c1">//nlogn</span>

<span class="c1">//解释空间复杂度O(logn)~O(n)</span>
<span class="c1">//主要是递归造成的栈空间的使用</span>
<span class="c1">//最好情况递归树深度为logn，最坏情况为n</span>

<span class="c1">//快排的最差情况什么时候发生？</span>
<span class="c1">//1. 已排序</span>
<span class="c1">//2. 数值全部相等（1的特殊情况）</span>
<span class="c1">//在上面的情况下选择的标定元素一直为第一个，则时间复杂度变为O(n^2)</span>

<span class="c1">//快速排序，平均情况O(nlogn),最好O(nlogn)，最坏O(n^2)（选择标定元素有关），空间复杂度O(logn)~O(n)，不稳定</span>

<span class="cm">/**************************************************************************</span>
<span class="cm">**  要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;</span>
<span class="cm">**  要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;</span>
<span class="cm">**  要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;</span>
<span class="cm">**  通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。</span>
<span class="cm">**  要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。</span>
<span class="cm">**  要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</span>
<span class="cm">*************************************************************************/</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="c1">//双路快排，尽量写这种</span>
<span class="c1">//begin,begin+1...i...j...end</span>
<span class="kt">int</span> <span class="nf">partition2</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
    <span class="c1">//产生start和end之间的随机数</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>

    <span class="c1">//将选中的数字交换到start位置</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>

    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>

    <span class="c1">//选择的pivot为start位置</span>
    <span class="c1">//data[start+1, i) &lt;= pivot   i-1 为小于v的最后一个元素，i为当前左边访问的元素</span>
    <span class="c1">//data(j, end] &gt;= pivot  j+1 为大于v的第一个元素，j为当前右边访问的元素</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">){</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">)</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">pivot</span><span class="p">)</span>
            <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

        <span class="c1">//下面这两行，swap交换之后，双方需要移动，否则会增加一次无用的比较</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="n">j</span><span class="o">--</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//最后j停止在&lt;= v的最后一个位置， i停止在&gt;=pivot的第一个位置，pivot与j进行交换</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">swapOffer</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//单路随机快排</span>
<span class="c1">//begin,begin+1...small,small+1...end</span>
<span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
    <span class="c1">//产生start和end之间的随机数</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>

    <span class="c1">//将选中的数字交换到start位置</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>

    <span class="c1">//选择的pivot为start位置</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>

    <span class="c1">//我们要达到这样的效果</span>
    <span class="c1">//data[start+1, small] &lt; v   small为小于pivot的最后一个元素</span>
    <span class="c1">//data[small+1, i - 1] &gt;= v   small+1为大于等于pivot的第一个元素</span>

    <span class="c1">//注意small的取值,small是为了标识小于</span>
    <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">){</span>
            <span class="c1">//若当前的元素小于pivot，需要将该元素放到data[start+1, small]中紧挨着small位置</span>
            <span class="c1">//将small+1和i进行交换，并将small的长度加长</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="o">++</span><span class="n">small</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//最后将start放在应该的位置，即small和small+1之间，因为左侧全是小于pivot的，因此将small和pivot交换</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">small</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">small</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">quickSortOffer</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">partition2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>  <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="n">quickSortOffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>  <span class="n">start</span><span class="p">,</span> <span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">quickSortOffer</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">20</span> <span class="p">};</span>
    <span class="n">quickSortOffer</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>  <span class="c1">//0表示从数组0位置开始，到4位置排序 </span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_5">堆排序<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="c1">//堆排序思想：将待排序列先构造一个最大堆，堆顶元素即为最大值，然后移走堆顶元素，调整剩余元素为最大堆，如此反复执行，便得到有序序列</span>
<span class="c1">//若从小到大排列，建立最大堆</span>
<span class="c1">//若从大到小排列，建立最小堆</span>

<span class="c1">//堆排序，平均情况O(nlogn),最好O(nlogn)，最坏O(nlogn),空间复杂度O(1)，不稳定</span>

<span class="c1">//解释时间复杂度O(nlogn)</span>
<span class="c1">//建立堆的过程是nlogn,遍历所有非叶子结点，将其和子树调整为最大堆</span>
<span class="c1">//调整堆的过程是logn，整体是nlogn</span>

<span class="c1">//由数组变为最大堆有两种方式，一种是逐个插入（O(n)），一种是heapify(从第一个非叶子结点开始调整，bottom to up)（O(1)）</span>
<span class="c1">//大话数据结构书上的排序基本都是数组的0位置不放元素，从1开始</span>
<span class="c1">//这里从0位置开始</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">build_max_heap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">heapadjust</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">build_max_heap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//将堆顶的元素和最后一个元素交换位置</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="c1">//每次将数组前面的部分再调整为最大堆，后续调整的时候传进去的就是当前数组能取到的最大下标了，因为i赋初值时已经解决</span>
        <span class="n">heapadjust</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>    
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//建堆的意思是将数组转换成最大堆</span>
<span class="c1">//本质：从下往上，从右往左，将每个非叶子结点当做根节点，将其和子树调整成最大堆，首先找到最后一个叶子结点的父节点len / 2 - 1</span>
<span class="c1">//最大堆，每个结点都大于等于左右孩子结点的值</span>
<span class="kt">void</span> <span class="nf">build_max_heap</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">//建堆</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heapadjust</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>              <span class="c1">//建堆的时候应该传进去len-1，即当前数组能取到的最大下标，即保证堆调整过程中左右孩子不会数组越界</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//以i当做根节点，调整其和其子树为最大堆</span>
<span class="kt">void</span> <span class="nf">heapadjust</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">temp</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="c1">//当前结点为j，左孩子序号是2*i，右孩子序号是2*i+1</span>
    <span class="c1">//这里的结点从0开始，不是从1开始，因此左孩子序号是2*i + 1，右孩子序号是2*i+2</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span> <span class="n">j</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">){</span>
        <span class="c1">//先比较左右孩子,找到左右孩子中较大的那个</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="o">++</span><span class="n">j</span><span class="p">;</span>

        <span class="c1">//如果左右孩子中最大值小于当前值，则不需要移动</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">temp</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="c1">//若最大值大于当前值，需要将最大值往前移动，赋给i位置</span>
        <span class="c1">//此时不要动j，直到找到j所在位置再赋值</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

        <span class="c1">//将当前值和左右孩子比较后，若移动了，则继续往下比较，将j向下移动到刚才较大的孩子处</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//直到找到temp的合适位置</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">a</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">heap_sort</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d &quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_6">二叉树非递归遍历<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="c1">//二叉树的前序，中序和后序遍历是根据根结点的位置来判断</span>
<span class="c1">//前序：根左右</span>
<span class="c1">//中序：左根右</span>
<span class="c1">//后序：左右根</span>
<span class="c1">//叶子结点也需要判断左右节点，只不过左右节点都是空</span>


<span class="c1">//非递归前序遍历，根左右</span>
<span class="c1">//(1) 从根结点开始，向左遍历压栈并输出</span>
<span class="c1">//(2) 一直找到二叉树最左边的结点，将最左侧的叶子结点压入栈</span>
<span class="c1">//(3) 出栈，指向该结点的右孩子</span>
<span class="c1">//(4) 将右孩子作为根节点重复(1)(2)(3)</span>
<span class="kt">void</span> <span class="nf">Pretravel</span><span class="p">(</span><span class="n">BiNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">stack</span><span class="o">&lt;</span><span class="n">BiNode</span><span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span>
    <span class="n">BiNode</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">||</span> <span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>


        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//非递归中序遍历，左根右</span>
<span class="c1">//先输出最左侧叶子结点</span>
<span class="c1">//(1) 从根结点开始，往左遍历压栈</span>
<span class="c1">//(2) 找到最左侧的叶子结点,也将其压栈</span>
<span class="c1">//(3) 出栈，输出结点值，并指向该结点的右孩子</span>
<span class="c1">//(4) 将右孩子作为根结点继续(1)(2)(3)</span>
<span class="kt">void</span> <span class="nf">Intravel</span><span class="p">(</span><span class="n">BiNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">BiNode</span><span class="o">*&gt;</span><span class="n">st</span><span class="p">;</span>
    <span class="n">BiNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">p</span><span class="p">){</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//非递归后序遍历，左右根</span>
<span class="c1">// 维护一个pre结点</span>
<span class="c1">//(1) 从根结点开始，往左遍历压栈</span>
<span class="c1">//(2) 找到最左侧的叶子结点,也将其压栈</span>
<span class="c1">//(3) 出栈，判断当前的结点是不是叶子结点或是不是根结点(上一次访问的是右孩子)</span>
<span class="c1">//(4) 若是，输出结点值，更新pre指针</span>
<span class="c1">//(5) 若不是，指向右孩子，重复(1)(2)(3)(4)</span>
<span class="kt">void</span> <span class="nf">behtravel</span><span class="p">(</span><span class="n">BiNode</span><span class="o">*</span> <span class="n">root</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">BiNode</span> <span class="o">*&gt;</span> <span class="n">st</span><span class="p">;</span>
    <span class="n">BiNode</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">BiNode</span> <span class="o">*</span> <span class="n">pre</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span> <span class="o">||</span> <span class="n">p</span><span class="p">){</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">){</span>
            <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lchild</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
            <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

            <span class="c1">//右孩子为空(左叶子结点和右叶子结点) 或 刚刚访问的是该结点的右孩子(根结点)</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span> <span class="o">||</span> <span class="n">pre</span> <span class="o">==</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">){</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
                <span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//右孩子不为空，则将刚刚出栈的结点重新压入，指向结点的右孩子</span>
            <span class="k">else</span><span class="p">{</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">rchild</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_7">单例模式<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="c1">//单例思路：静态成员建议在类外进行初始化，但在类内也可以初始化，只是通过类名访问静态成员的属性时，访问不到</span>
<span class="c1">//构造函数声明为private或protect防止被外部函数实例化</span>
<span class="c1">//内部保存一个private static的类指针保存唯一的实例</span>
<span class="c1">//实例的动作由一个public的类方法代劳</span>

<span class="c1">//懒汉模式：在getinstance中实例化</span>
<span class="c1">//饿汉模式：在单例类定义时实例化</span>

<span class="c1">//**********************</span>
<span class="c1">//懒汉模式最初实现</span>
<span class="c1">//**********************</span>
<span class="c1">//#include &lt;iostream&gt;</span>
<span class="c1">//</span>
<span class="c1">//using namespace std;</span>
<span class="c1">//</span>
<span class="c1">//class single{</span>
<span class="c1">//private:</span>
<span class="c1">//  static single *p;</span>
<span class="c1">//  single(){}</span>
<span class="c1">//  ~single(){}</span>
<span class="c1">//</span>
<span class="c1">//public:</span>
<span class="c1">//  static single* getinstance();</span>
<span class="c1">//};</span>
<span class="c1">//</span>
<span class="c1">//single* single::p = NULL;</span>
<span class="c1">//single* single::getinstance(){</span>
<span class="c1">//  if (NULL == p)</span>
<span class="c1">//      p = new single;</span>
<span class="c1">//</span>
<span class="c1">//  return p;</span>
<span class="c1">//}</span>


<span class="c1">//**********************</span>
<span class="c1">//懒汉模式线程安全经典实现</span>
<span class="c1">//**********************</span>
<span class="c1">//#include &lt;iostream&gt;</span>
<span class="c1">//#include &lt;unistd.h&gt;</span>
<span class="c1">//#include &lt;pthread.h&gt;</span>
<span class="c1">//</span>
<span class="c1">//using namespace std;</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//class single{</span>
<span class="c1">//private:</span>
<span class="c1">//  static single *p;</span>
<span class="c1">//  static pthread_mutex_t lock;</span>
<span class="c1">//  single(){</span>
<span class="c1">//      pthread_mutex_init(&amp;lock, NULL);</span>
<span class="c1">//  }</span>
<span class="c1">//  ~single(){}</span>
<span class="c1">//</span>
<span class="c1">//public:</span>
<span class="c1">//  static single* getinstance();</span>
<span class="c1">//</span>
<span class="c1">//};</span>
<span class="c1">//pthread_mutex_t single::lock;</span>
<span class="c1">//single* single::p = NULL;</span>
<span class="c1">//single* single::getinstance(){</span>
<span class="c1">//  if (NULL == p){</span>
<span class="c1">//      pthread_mutex_lock(&amp;lock);</span>
<span class="c1">//      if (NULL == p)</span>
<span class="c1">//          p = new single;</span>
<span class="c1">//  }</span>
<span class="c1">//  pthread_mutex_unlock(&amp;lock);</span>
<span class="c1">//  return p;</span>
<span class="c1">//}</span>

<span class="c1">//**************************************************</span>
<span class="c1">//懒汉模式线程安全内部静态变量实现</span>
<span class="c1">//将经典实现中的私有唯一实例删掉</span>
<span class="c1">//改为在instance函数里定义一个静态的实例</span>
<span class="c1">//也可以保证拥有唯一实例，在返回时只需要返回其指针就可以</span>
<span class="c1">//**************************************************</span>
<span class="c1">//#include &lt;iostream&gt;</span>
<span class="c1">//#include &lt;unistd.h&gt;</span>
<span class="c1">//#include &lt;pthread.h&gt;</span>
<span class="c1">//</span>
<span class="c1">//using namespace std;</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//class single{</span>
<span class="c1">//private:</span>
<span class="c1">//  static pthread_mutex_t lock;</span>
<span class="c1">//  single(){</span>
<span class="c1">//      pthread_mutex_init(&amp;lock, NULL);</span>
<span class="c1">//  }</span>
<span class="c1">//  ~single(){}</span>
<span class="c1">//</span>
<span class="c1">//public:</span>
<span class="c1">//  static single* getinstance();</span>
<span class="c1">//</span>
<span class="c1">//};</span>
<span class="c1">//pthread_mutex_t single::lock;</span>
<span class="c1">//single* single::getinstance(){</span>
<span class="c1">//  pthread_mutex_lock(&amp;lock);</span>
<span class="c1">//  static single obj;</span>
<span class="c1">//  pthread_mutex_unlock(&amp;lock);</span>
<span class="c1">//  return &amp;obj;</span>
<span class="c1">//}</span>

<span class="c1">//************************************************************</span>
<span class="c1">//饿汉模式，在定义单例类最初就实例化，此后返回的就一个，感觉相当于全局变量</span>
<span class="c1">//在饿汉模式下，在单例类定义的时候就已经定义了一个对象，对类进行了初始化。</span>
<span class="c1">//后面不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。</span>
<span class="c1">//所以是线程安全的，不需要在成员函数getinstance中加锁。</span>
<span class="c1">//************************************************************</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">single</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">single</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">single</span><span class="p">(){}</span>
    <span class="o">~</span><span class="n">single</span><span class="p">(){}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">single</span><span class="o">*</span> <span class="n">getinstance</span><span class="p">();</span>

<span class="p">};</span>
<span class="n">single</span><span class="o">*</span> <span class="n">single</span><span class="o">::</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">single</span><span class="p">();</span>
<span class="n">single</span><span class="o">*</span> <span class="n">single</span><span class="o">::</span><span class="n">getinstance</span><span class="p">(){</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(){</span>

    <span class="n">single</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">single</span><span class="o">::</span><span class="n">getinstance</span><span class="p">();</span>
    <span class="n">single</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">single</span><span class="o">::</span><span class="n">getinstance</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;same&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_8">智能指针<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="c1">//智能指针的设计与实现</span>
<span class="c1">//智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。</span>
<span class="c1">//每次创建类的新对象时，初始化指针并将引用计数置为1；</span>
<span class="c1">//当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；</span>
<span class="c1">//对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；</span>
<span class="c1">//调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</span>
<span class="c1">//所有的智能指针都会重载 -&gt; 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">SmartPointer</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">_ptr</span><span class="p">;</span>
    <span class="c1">//在赋值时，需要修改赋值后指针的引用计数</span>
    <span class="kt">size_t</span><span class="o">*</span> <span class="n">_count</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">//初始化</span>
    <span class="n">SmartPointer</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">:</span>
        <span class="n">_ptr</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_ptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">_count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">size_t</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">_count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">size_t</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//拷贝构造</span>
    <span class="n">SmartPointer</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartPointer</span><span class="o">&amp;</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">_ptr</span><span class="p">;</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">_count</span><span class="p">;</span>
            <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//重载=运算符</span>
    <span class="n">SmartPointer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SmartPointer</span><span class="o">&amp;</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">.</span><span class="n">_ptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span><span class="p">;</span>
                <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">_ptr</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">.</span><span class="n">_count</span><span class="p">;</span>
        <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//重载*</span>
    <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="c1">//重载-&gt;</span>
    <span class="n">T</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">SmartPointer</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//因为引用计数是指针，当智能指针声明为空时，仍需释放</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span><span class="p">;</span>
            <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;释放&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
            <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_ptr</span><span class="p">;</span>
            <span class="k">delete</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;释放&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">size_t</span> <span class="n">use_count</span><span class="p">(){</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">{</span>
        <span class="c1">//只初始化了两次</span>
        <span class="n">SmartPointer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span>
        <span class="n">SmartPointer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp2</span><span class="p">(</span><span class="n">sp</span><span class="p">);</span>
        <span class="n">SmartPointer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp3</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
        <span class="n">sp2</span> <span class="o">=</span> <span class="n">sp3</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sp3</span><span class="p">.</span><span class="n">use_count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="c1">//SmartPointer&lt;int&gt; sp(NULL);</span>
        <span class="c1">//std::cout &lt;&lt; sp.use_count() &lt;&lt; std::endl;</span>
    <span class="p">}</span>

    <span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


<h1 id="_9">类的默认函数<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h1>
<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">String</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">String</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">_pstr</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="mi">1</span><span class="p">]())</span>
    <span class="p">{}</span>

    <span class="n">String</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pstr</span><span class="p">)</span> 
    <span class="o">:</span> <span class="n">_pstr</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">pstr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]())</span>
    <span class="p">{</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">_pstr</span><span class="p">,</span> <span class="n">pstr</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;String(const char *)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//</span>
    <span class="c1">//复制控制函数</span>
    <span class="n">String</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">_pstr</span><span class="p">(</span><span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]())</span>
    <span class="p">{</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">_pstr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span><span class="p">);</span>   
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;String(const String &amp;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">String</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;String&amp; operator=(const String &amp;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="p">[]</span> <span class="n">_pstr</span><span class="p">;</span>
            <span class="n">_pstr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]();</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">_pstr</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//如果传递右值时，具有移动语义的函数会优先执行</span>
    <span class="c1">//移动构造函数</span>
    <span class="n">String</span><span class="p">(</span><span class="n">String</span> <span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">_pstr</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//将临时对象的指针设为空</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;String(String &amp;&amp;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//移动赋值运算符函数</span>
    <span class="n">String</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">String</span> <span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;String &amp; operator=(String &amp;&amp;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">delete</span> <span class="p">[]</span> <span class="n">_pstr</span><span class="p">;</span>

            <span class="n">_pstr</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span><span class="p">;</span>
            <span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>


    <span class="o">~</span><span class="n">String</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="p">[]</span> <span class="n">_pstr</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;~String()&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">_pstr</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">String</span> <span class="nf">str</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">);</span>

<span class="c1">//右值引用本身是左值还是右值，取决于其有没有名字</span>

<span class="c1">//右值引用作为函数的返回值， 此时是右值</span>
<span class="n">String</span> <span class="o">&amp;&amp;</span> <span class="n">func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">_pstr</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" class="btn btn-neutral float-right" title="Linux系统编程及基本命令">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" class="btn btn-neutral" title="海量数据处理"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
          <a href="https://github.com/zwiley/mybook/" class="fa fa-github" style="float: left; color: #fcfcfc"> GitHub</a>
      
      
        <span><a href="../../%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../%E9%A1%B9%E7%9B%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
